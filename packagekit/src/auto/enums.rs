// Generated by gir (https://github.com/gtk-rs/gir @ 1c7a6b57a5fc)
// from gir-files (https://github.com/gtk-rs/gir-files.git @ 21b29d0e0c1a)
// from packagekit-gir-files
// DO NOT EDIT

use glib::{prelude::*,translate::*};

/// The authorization result
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PkAuthorizeEnum")]
pub enum AuthorizeEnum {
    #[doc(alias = "PK_AUTHORIZE_ENUM_UNKNOWN")]
    Unknown,
    #[doc(alias = "PK_AUTHORIZE_ENUM_YES")]
    Yes,
    #[doc(alias = "PK_AUTHORIZE_ENUM_NO")]
    No,
    #[doc(alias = "PK_AUTHORIZE_ENUM_INTERACTIVE")]
    Interactive,
    #[doc(alias = "PK_AUTHORIZE_ENUM_LAST")]
    Last,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for AuthorizeEnum {
    type GlibType = ffi::PkAuthorizeEnum;

    #[inline]
fn into_glib(self) -> ffi::PkAuthorizeEnum {
match self {
            Self::Unknown => ffi::PK_AUTHORIZE_ENUM_UNKNOWN,
            Self::Yes => ffi::PK_AUTHORIZE_ENUM_YES,
            Self::No => ffi::PK_AUTHORIZE_ENUM_NO,
            Self::Interactive => ffi::PK_AUTHORIZE_ENUM_INTERACTIVE,
            Self::Last => ffi::PK_AUTHORIZE_ENUM_LAST,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::PkAuthorizeEnum> for AuthorizeEnum {
    #[inline]
unsafe fn from_glib(value: ffi::PkAuthorizeEnum) -> Self {
        
match value {
            ffi::PK_AUTHORIZE_ENUM_UNKNOWN => Self::Unknown,
            ffi::PK_AUTHORIZE_ENUM_YES => Self::Yes,
            ffi::PK_AUTHORIZE_ENUM_NO => Self::No,
            ffi::PK_AUTHORIZE_ENUM_INTERACTIVE => Self::Interactive,
            ffi::PK_AUTHORIZE_ENUM_LAST => Self::Last,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for AuthorizeEnum {
                #[inline]
    #[doc(alias = "pk_authorize_enum_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::pk_authorize_enum_get_type()) }
                }
            }

impl glib::HasParamSpec for AuthorizeEnum {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for AuthorizeEnum {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for AuthorizeEnum {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for AuthorizeEnum {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<AuthorizeEnum> for glib::Value {
    #[inline]
    fn from(v: AuthorizeEnum) -> Self {
        ToValue::to_value(&v)
    }
}

/// Errors that can be thrown
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PkClientError")]
pub enum ClientError {
    #[doc(alias = "PK_CLIENT_ERROR_FAILED")]
    Failed,
    #[doc(alias = "PK_CLIENT_ERROR_FAILED_AUTH")]
    FailedAuth,
    #[doc(alias = "PK_CLIENT_ERROR_NO_TID")]
    NoTid,
    #[doc(alias = "PK_CLIENT_ERROR_ALREADY_TID")]
    AlreadyTid,
    #[doc(alias = "PK_CLIENT_ERROR_ROLE_UNKNOWN")]
    RoleUnknown,
    #[doc(alias = "PK_CLIENT_ERROR_CANNOT_START_DAEMON")]
    CannotStartDaemon,
    #[doc(alias = "PK_CLIENT_ERROR_INVALID_INPUT")]
    InvalidInput,
    #[doc(alias = "PK_CLIENT_ERROR_INVALID_FILE")]
    InvalidFile,
    #[doc(alias = "PK_CLIENT_ERROR_NOT_SUPPORTED")]
    NotSupported,
    #[doc(alias = "PK_CLIENT_ERROR_DECLINED_SIMULATION")]
    DeclinedSimulation,
    #[doc(alias = "PK_CLIENT_ERROR_DECLINED_INTERACTION")]
    DeclinedInteraction,
    #[doc(alias = "PK_CLIENT_ERROR_LAST")]
    Last,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ClientError {
    type GlibType = ffi::PkClientError;

    #[inline]
fn into_glib(self) -> ffi::PkClientError {
match self {
            Self::Failed => ffi::PK_CLIENT_ERROR_FAILED,
            Self::FailedAuth => ffi::PK_CLIENT_ERROR_FAILED_AUTH,
            Self::NoTid => ffi::PK_CLIENT_ERROR_NO_TID,
            Self::AlreadyTid => ffi::PK_CLIENT_ERROR_ALREADY_TID,
            Self::RoleUnknown => ffi::PK_CLIENT_ERROR_ROLE_UNKNOWN,
            Self::CannotStartDaemon => ffi::PK_CLIENT_ERROR_CANNOT_START_DAEMON,
            Self::InvalidInput => ffi::PK_CLIENT_ERROR_INVALID_INPUT,
            Self::InvalidFile => ffi::PK_CLIENT_ERROR_INVALID_FILE,
            Self::NotSupported => ffi::PK_CLIENT_ERROR_NOT_SUPPORTED,
            Self::DeclinedSimulation => ffi::PK_CLIENT_ERROR_DECLINED_SIMULATION,
            Self::DeclinedInteraction => ffi::PK_CLIENT_ERROR_DECLINED_INTERACTION,
            Self::Last => ffi::PK_CLIENT_ERROR_LAST,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::PkClientError> for ClientError {
    #[inline]
unsafe fn from_glib(value: ffi::PkClientError) -> Self {
        
match value {
            ffi::PK_CLIENT_ERROR_FAILED => Self::Failed,
            ffi::PK_CLIENT_ERROR_FAILED_AUTH => Self::FailedAuth,
            ffi::PK_CLIENT_ERROR_NO_TID => Self::NoTid,
            ffi::PK_CLIENT_ERROR_ALREADY_TID => Self::AlreadyTid,
            ffi::PK_CLIENT_ERROR_ROLE_UNKNOWN => Self::RoleUnknown,
            ffi::PK_CLIENT_ERROR_CANNOT_START_DAEMON => Self::CannotStartDaemon,
            ffi::PK_CLIENT_ERROR_INVALID_INPUT => Self::InvalidInput,
            ffi::PK_CLIENT_ERROR_INVALID_FILE => Self::InvalidFile,
            ffi::PK_CLIENT_ERROR_NOT_SUPPORTED => Self::NotSupported,
            ffi::PK_CLIENT_ERROR_DECLINED_SIMULATION => Self::DeclinedSimulation,
            ffi::PK_CLIENT_ERROR_DECLINED_INTERACTION => Self::DeclinedInteraction,
            ffi::PK_CLIENT_ERROR_LAST => Self::Last,
            value => Self::__Unknown(value),
}
}
}

impl glib::error::ErrorDomain for ClientError {
    #[inline]
    fn domain() -> glib::Quark {
        
        unsafe { from_glib(ffi::pk_client_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        match unsafe { from_glib(code) } {
            Self::__Unknown(_) => Some(Self::Failed),
            value => Some(value),
}
    }
}

impl StaticType for ClientError {
                #[inline]
    #[doc(alias = "pk_client_error_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::pk_client_error_get_type()) }
                }
            }

impl glib::HasParamSpec for ClientError {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for ClientError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ClientError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ClientError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ClientError> for glib::Value {
    #[inline]
    fn from(v: ClientError) -> Self {
        ToValue::to_value(&v)
    }
}

/// Errors that can be thrown
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PkControlError")]
pub enum ControlError {
    #[doc(alias = "PK_CONTROL_ERROR_FAILED")]
    Failed,
    #[doc(alias = "PK_CONTROL_ERROR_CANNOT_START_DAEMON")]
    CannotStartDaemon,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ControlError {
    type GlibType = ffi::PkControlError;

    #[inline]
fn into_glib(self) -> ffi::PkControlError {
match self {
            Self::Failed => ffi::PK_CONTROL_ERROR_FAILED,
            Self::CannotStartDaemon => ffi::PK_CONTROL_ERROR_CANNOT_START_DAEMON,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::PkControlError> for ControlError {
    #[inline]
unsafe fn from_glib(value: ffi::PkControlError) -> Self {
        
match value {
            ffi::PK_CONTROL_ERROR_FAILED => Self::Failed,
            ffi::PK_CONTROL_ERROR_CANNOT_START_DAEMON => Self::CannotStartDaemon,
            value => Self::__Unknown(value),
}
}
}

impl glib::error::ErrorDomain for ControlError {
    #[inline]
    fn domain() -> glib::Quark {
        
        unsafe { from_glib(ffi::pk_control_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        match unsafe { from_glib(code) } {
            Self::__Unknown(_) => Some(Self::Failed),
            value => Some(value),
}
    }
}

impl StaticType for ControlError {
                #[inline]
    #[doc(alias = "pk_control_error_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::pk_control_error_get_type()) }
                }
            }

impl glib::HasParamSpec for ControlError {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for ControlError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ControlError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ControlError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ControlError> for glib::Value {
    #[inline]
    fn from(v: ControlError) -> Self {
        ToValue::to_value(&v)
    }
}

/// The distro upgrade status
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PkDistroUpgradeEnum")]
pub enum DistroUpgradeEnum {
    #[doc(alias = "PK_DISTRO_UPGRADE_ENUM_UNKNOWN")]
    Unknown,
    #[doc(alias = "PK_DISTRO_UPGRADE_ENUM_STABLE")]
    Stable,
    #[doc(alias = "PK_DISTRO_UPGRADE_ENUM_UNSTABLE")]
    Unstable,
    #[doc(alias = "PK_DISTRO_UPGRADE_ENUM_LAST")]
    Last,
#[doc(hidden)]
    __Unknown(i32),
}

impl DistroUpgradeEnum {
    #[cfg(feature = "v0_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
    #[doc(alias = "pk_distro_upgrade_enum_from_string")]
    pub fn from_string(upgrade: &str) -> DistroUpgradeEnum {
        unsafe {
            from_glib(ffi::pk_distro_upgrade_enum_from_string(upgrade.to_glib_none().0))
        }
    }

    #[cfg(feature = "v0_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
    #[doc(alias = "pk_distro_upgrade_enum_to_string")]
    #[doc(alias = "to_string")]
    pub fn to_str(self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::pk_distro_upgrade_enum_to_string(self.into_glib()))
        }
    }
}

#[doc(hidden)]
impl IntoGlib for DistroUpgradeEnum {
    type GlibType = ffi::PkDistroUpgradeEnum;

    #[inline]
fn into_glib(self) -> ffi::PkDistroUpgradeEnum {
match self {
            Self::Unknown => ffi::PK_DISTRO_UPGRADE_ENUM_UNKNOWN,
            Self::Stable => ffi::PK_DISTRO_UPGRADE_ENUM_STABLE,
            Self::Unstable => ffi::PK_DISTRO_UPGRADE_ENUM_UNSTABLE,
            Self::Last => ffi::PK_DISTRO_UPGRADE_ENUM_LAST,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::PkDistroUpgradeEnum> for DistroUpgradeEnum {
    #[inline]
unsafe fn from_glib(value: ffi::PkDistroUpgradeEnum) -> Self {
        
match value {
            ffi::PK_DISTRO_UPGRADE_ENUM_UNKNOWN => Self::Unknown,
            ffi::PK_DISTRO_UPGRADE_ENUM_STABLE => Self::Stable,
            ffi::PK_DISTRO_UPGRADE_ENUM_UNSTABLE => Self::Unstable,
            ffi::PK_DISTRO_UPGRADE_ENUM_LAST => Self::Last,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for DistroUpgradeEnum {
                #[inline]
    #[doc(alias = "pk_distro_upgrade_enum_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::pk_distro_upgrade_enum_get_type()) }
                }
            }

impl glib::HasParamSpec for DistroUpgradeEnum {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for DistroUpgradeEnum {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for DistroUpgradeEnum {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for DistroUpgradeEnum {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<DistroUpgradeEnum> for glib::Value {
    #[inline]
    fn from(v: DistroUpgradeEnum) -> Self {
        ToValue::to_value(&v)
    }
}

/// The error type
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PkErrorEnum")]
pub enum ErrorEnum {
    #[doc(alias = "PK_ERROR_ENUM_UNKNOWN")]
    Unknown,
    #[doc(alias = "PK_ERROR_ENUM_OOM")]
    Oom,
    #[doc(alias = "PK_ERROR_ENUM_NO_NETWORK")]
    NoNetwork,
    #[doc(alias = "PK_ERROR_ENUM_NOT_SUPPORTED")]
    NotSupported,
    #[doc(alias = "PK_ERROR_ENUM_INTERNAL_ERROR")]
    InternalError,
    #[doc(alias = "PK_ERROR_ENUM_GPG_FAILURE")]
    GpgFailure,
    #[doc(alias = "PK_ERROR_ENUM_PACKAGE_ID_INVALID")]
    PackageIdInvalid,
    #[doc(alias = "PK_ERROR_ENUM_PACKAGE_NOT_INSTALLED")]
    PackageNotInstalled,
    #[doc(alias = "PK_ERROR_ENUM_PACKAGE_NOT_FOUND")]
    PackageNotFound,
    #[doc(alias = "PK_ERROR_ENUM_PACKAGE_ALREADY_INSTALLED")]
    PackageAlreadyInstalled,
    #[doc(alias = "PK_ERROR_ENUM_PACKAGE_DOWNLOAD_FAILED")]
    PackageDownloadFailed,
    #[doc(alias = "PK_ERROR_ENUM_GROUP_NOT_FOUND")]
    GroupNotFound,
    #[doc(alias = "PK_ERROR_ENUM_GROUP_LIST_INVALID")]
    GroupListInvalid,
    #[doc(alias = "PK_ERROR_ENUM_DEP_RESOLUTION_FAILED")]
    DepResolutionFailed,
    #[doc(alias = "PK_ERROR_ENUM_FILTER_INVALID")]
    FilterInvalid,
    #[doc(alias = "PK_ERROR_ENUM_CREATE_THREAD_FAILED")]
    CreateThreadFailed,
    #[doc(alias = "PK_ERROR_ENUM_TRANSACTION_ERROR")]
    TransactionError,
    #[doc(alias = "PK_ERROR_ENUM_TRANSACTION_CANCELLED")]
    TransactionCancelled,
    #[doc(alias = "PK_ERROR_ENUM_NO_CACHE")]
    NoCache,
    #[doc(alias = "PK_ERROR_ENUM_REPO_NOT_FOUND")]
    RepoNotFound,
    #[doc(alias = "PK_ERROR_ENUM_CANNOT_REMOVE_SYSTEM_PACKAGE")]
    CannotRemoveSystemPackage,
    #[doc(alias = "PK_ERROR_ENUM_PROCESS_KILL")]
    ProcessKill,
    #[doc(alias = "PK_ERROR_ENUM_FAILED_INITIALIZATION")]
    FailedInitialization,
    #[doc(alias = "PK_ERROR_ENUM_FAILED_FINALISE")]
    FailedFinalise,
    #[doc(alias = "PK_ERROR_ENUM_FAILED_CONFIG_PARSING")]
    FailedConfigParsing,
    #[doc(alias = "PK_ERROR_ENUM_CANNOT_CANCEL")]
    CannotCancel,
    #[doc(alias = "PK_ERROR_ENUM_CANNOT_GET_LOCK")]
    CannotGetLock,
    #[doc(alias = "PK_ERROR_ENUM_NO_PACKAGES_TO_UPDATE")]
    NoPackagesToUpdate,
    #[doc(alias = "PK_ERROR_ENUM_CANNOT_WRITE_REPO_CONFIG")]
    CannotWriteRepoConfig,
    #[doc(alias = "PK_ERROR_ENUM_LOCAL_INSTALL_FAILED")]
    LocalInstallFailed,
    #[doc(alias = "PK_ERROR_ENUM_BAD_GPG_SIGNATURE")]
    BadGpgSignature,
    #[doc(alias = "PK_ERROR_ENUM_MISSING_GPG_SIGNATURE")]
    MissingGpgSignature,
    #[doc(alias = "PK_ERROR_ENUM_CANNOT_INSTALL_SOURCE_PACKAGE")]
    CannotInstallSourcePackage,
    #[doc(alias = "PK_ERROR_ENUM_REPO_CONFIGURATION_ERROR")]
    RepoConfigurationError,
    #[doc(alias = "PK_ERROR_ENUM_NO_LICENSE_AGREEMENT")]
    NoLicenseAgreement,
    #[doc(alias = "PK_ERROR_ENUM_FILE_CONFLICTS")]
    FileConflicts,
    #[doc(alias = "PK_ERROR_ENUM_PACKAGE_CONFLICTS")]
    PackageConflicts,
    #[doc(alias = "PK_ERROR_ENUM_REPO_NOT_AVAILABLE")]
    RepoNotAvailable,
    #[doc(alias = "PK_ERROR_ENUM_INVALID_PACKAGE_FILE")]
    InvalidPackageFile,
    #[doc(alias = "PK_ERROR_ENUM_PACKAGE_INSTALL_BLOCKED")]
    PackageInstallBlocked,
    #[doc(alias = "PK_ERROR_ENUM_PACKAGE_CORRUPT")]
    PackageCorrupt,
    #[doc(alias = "PK_ERROR_ENUM_ALL_PACKAGES_ALREADY_INSTALLED")]
    AllPackagesAlreadyInstalled,
    #[doc(alias = "PK_ERROR_ENUM_FILE_NOT_FOUND")]
    FileNotFound,
    #[doc(alias = "PK_ERROR_ENUM_NO_MORE_MIRRORS_TO_TRY")]
    NoMoreMirrorsToTry,
    #[doc(alias = "PK_ERROR_ENUM_NO_DISTRO_UPGRADE_DATA")]
    NoDistroUpgradeData,
    #[doc(alias = "PK_ERROR_ENUM_INCOMPATIBLE_ARCHITECTURE")]
    IncompatibleArchitecture,
    #[doc(alias = "PK_ERROR_ENUM_NO_SPACE_ON_DEVICE")]
    NoSpaceOnDevice,
    #[doc(alias = "PK_ERROR_ENUM_MEDIA_CHANGE_REQUIRED")]
    MediaChangeRequired,
    #[doc(alias = "PK_ERROR_ENUM_NOT_AUTHORIZED")]
    NotAuthorized,
    #[doc(alias = "PK_ERROR_ENUM_UPDATE_NOT_FOUND")]
    UpdateNotFound,
    #[doc(alias = "PK_ERROR_ENUM_CANNOT_INSTALL_REPO_UNSIGNED")]
    CannotInstallRepoUnsigned,
    #[doc(alias = "PK_ERROR_ENUM_CANNOT_UPDATE_REPO_UNSIGNED")]
    CannotUpdateRepoUnsigned,
    #[doc(alias = "PK_ERROR_ENUM_CANNOT_GET_FILELIST")]
    CannotGetFilelist,
    #[doc(alias = "PK_ERROR_ENUM_CANNOT_GET_REQUIRES")]
    CannotGetRequires,
    #[doc(alias = "PK_ERROR_ENUM_CANNOT_DISABLE_REPOSITORY")]
    CannotDisableRepository,
    #[doc(alias = "PK_ERROR_ENUM_RESTRICTED_DOWNLOAD")]
    RestrictedDownload,
    #[doc(alias = "PK_ERROR_ENUM_PACKAGE_FAILED_TO_CONFIGURE")]
    PackageFailedToConfigure,
    #[doc(alias = "PK_ERROR_ENUM_PACKAGE_FAILED_TO_BUILD")]
    PackageFailedToBuild,
    #[doc(alias = "PK_ERROR_ENUM_PACKAGE_FAILED_TO_INSTALL")]
    PackageFailedToInstall,
    #[doc(alias = "PK_ERROR_ENUM_PACKAGE_FAILED_TO_REMOVE")]
    PackageFailedToRemove,
    #[doc(alias = "PK_ERROR_ENUM_UPDATE_FAILED_DUE_TO_RUNNING_PROCESS")]
    UpdateFailedDueToRunningProcess,
    #[doc(alias = "PK_ERROR_ENUM_PACKAGE_DATABASE_CHANGED")]
    PackageDatabaseChanged,
    #[doc(alias = "PK_ERROR_ENUM_PROVIDE_TYPE_NOT_SUPPORTED")]
    ProvideTypeNotSupported,
    #[doc(alias = "PK_ERROR_ENUM_INSTALL_ROOT_INVALID")]
    InstallRootInvalid,
    #[doc(alias = "PK_ERROR_ENUM_CANNOT_FETCH_SOURCES")]
    CannotFetchSources,
    #[doc(alias = "PK_ERROR_ENUM_CANCELLED_PRIORITY")]
    CancelledPriority,
    #[doc(alias = "PK_ERROR_ENUM_UNFINISHED_TRANSACTION")]
    UnfinishedTransaction,
    #[doc(alias = "PK_ERROR_ENUM_LOCK_REQUIRED")]
    LockRequired,
    #[doc(alias = "PK_ERROR_ENUM_REPO_ALREADY_SET")]
    RepoAlreadySet,
    #[doc(alias = "PK_ERROR_ENUM_LAST")]
    Last,
#[doc(hidden)]
    __Unknown(i32),
}

impl ErrorEnum {
    #[cfg(feature = "v0_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
    #[doc(alias = "pk_error_enum_from_string")]
    pub fn from_string(code: &str) -> ErrorEnum {
        unsafe {
            from_glib(ffi::pk_error_enum_from_string(code.to_glib_none().0))
        }
    }

    #[cfg(feature = "v0_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
    #[doc(alias = "pk_error_enum_to_string")]
    #[doc(alias = "to_string")]
    pub fn to_str(self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::pk_error_enum_to_string(self.into_glib()))
        }
    }
}

#[doc(hidden)]
impl IntoGlib for ErrorEnum {
    type GlibType = ffi::PkErrorEnum;

    fn into_glib(self) -> ffi::PkErrorEnum {
match self {
            Self::Unknown => ffi::PK_ERROR_ENUM_UNKNOWN,
            Self::Oom => ffi::PK_ERROR_ENUM_OOM,
            Self::NoNetwork => ffi::PK_ERROR_ENUM_NO_NETWORK,
            Self::NotSupported => ffi::PK_ERROR_ENUM_NOT_SUPPORTED,
            Self::InternalError => ffi::PK_ERROR_ENUM_INTERNAL_ERROR,
            Self::GpgFailure => ffi::PK_ERROR_ENUM_GPG_FAILURE,
            Self::PackageIdInvalid => ffi::PK_ERROR_ENUM_PACKAGE_ID_INVALID,
            Self::PackageNotInstalled => ffi::PK_ERROR_ENUM_PACKAGE_NOT_INSTALLED,
            Self::PackageNotFound => ffi::PK_ERROR_ENUM_PACKAGE_NOT_FOUND,
            Self::PackageAlreadyInstalled => ffi::PK_ERROR_ENUM_PACKAGE_ALREADY_INSTALLED,
            Self::PackageDownloadFailed => ffi::PK_ERROR_ENUM_PACKAGE_DOWNLOAD_FAILED,
            Self::GroupNotFound => ffi::PK_ERROR_ENUM_GROUP_NOT_FOUND,
            Self::GroupListInvalid => ffi::PK_ERROR_ENUM_GROUP_LIST_INVALID,
            Self::DepResolutionFailed => ffi::PK_ERROR_ENUM_DEP_RESOLUTION_FAILED,
            Self::FilterInvalid => ffi::PK_ERROR_ENUM_FILTER_INVALID,
            Self::CreateThreadFailed => ffi::PK_ERROR_ENUM_CREATE_THREAD_FAILED,
            Self::TransactionError => ffi::PK_ERROR_ENUM_TRANSACTION_ERROR,
            Self::TransactionCancelled => ffi::PK_ERROR_ENUM_TRANSACTION_CANCELLED,
            Self::NoCache => ffi::PK_ERROR_ENUM_NO_CACHE,
            Self::RepoNotFound => ffi::PK_ERROR_ENUM_REPO_NOT_FOUND,
            Self::CannotRemoveSystemPackage => ffi::PK_ERROR_ENUM_CANNOT_REMOVE_SYSTEM_PACKAGE,
            Self::ProcessKill => ffi::PK_ERROR_ENUM_PROCESS_KILL,
            Self::FailedInitialization => ffi::PK_ERROR_ENUM_FAILED_INITIALIZATION,
            Self::FailedFinalise => ffi::PK_ERROR_ENUM_FAILED_FINALISE,
            Self::FailedConfigParsing => ffi::PK_ERROR_ENUM_FAILED_CONFIG_PARSING,
            Self::CannotCancel => ffi::PK_ERROR_ENUM_CANNOT_CANCEL,
            Self::CannotGetLock => ffi::PK_ERROR_ENUM_CANNOT_GET_LOCK,
            Self::NoPackagesToUpdate => ffi::PK_ERROR_ENUM_NO_PACKAGES_TO_UPDATE,
            Self::CannotWriteRepoConfig => ffi::PK_ERROR_ENUM_CANNOT_WRITE_REPO_CONFIG,
            Self::LocalInstallFailed => ffi::PK_ERROR_ENUM_LOCAL_INSTALL_FAILED,
            Self::BadGpgSignature => ffi::PK_ERROR_ENUM_BAD_GPG_SIGNATURE,
            Self::MissingGpgSignature => ffi::PK_ERROR_ENUM_MISSING_GPG_SIGNATURE,
            Self::CannotInstallSourcePackage => ffi::PK_ERROR_ENUM_CANNOT_INSTALL_SOURCE_PACKAGE,
            Self::RepoConfigurationError => ffi::PK_ERROR_ENUM_REPO_CONFIGURATION_ERROR,
            Self::NoLicenseAgreement => ffi::PK_ERROR_ENUM_NO_LICENSE_AGREEMENT,
            Self::FileConflicts => ffi::PK_ERROR_ENUM_FILE_CONFLICTS,
            Self::PackageConflicts => ffi::PK_ERROR_ENUM_PACKAGE_CONFLICTS,
            Self::RepoNotAvailable => ffi::PK_ERROR_ENUM_REPO_NOT_AVAILABLE,
            Self::InvalidPackageFile => ffi::PK_ERROR_ENUM_INVALID_PACKAGE_FILE,
            Self::PackageInstallBlocked => ffi::PK_ERROR_ENUM_PACKAGE_INSTALL_BLOCKED,
            Self::PackageCorrupt => ffi::PK_ERROR_ENUM_PACKAGE_CORRUPT,
            Self::AllPackagesAlreadyInstalled => ffi::PK_ERROR_ENUM_ALL_PACKAGES_ALREADY_INSTALLED,
            Self::FileNotFound => ffi::PK_ERROR_ENUM_FILE_NOT_FOUND,
            Self::NoMoreMirrorsToTry => ffi::PK_ERROR_ENUM_NO_MORE_MIRRORS_TO_TRY,
            Self::NoDistroUpgradeData => ffi::PK_ERROR_ENUM_NO_DISTRO_UPGRADE_DATA,
            Self::IncompatibleArchitecture => ffi::PK_ERROR_ENUM_INCOMPATIBLE_ARCHITECTURE,
            Self::NoSpaceOnDevice => ffi::PK_ERROR_ENUM_NO_SPACE_ON_DEVICE,
            Self::MediaChangeRequired => ffi::PK_ERROR_ENUM_MEDIA_CHANGE_REQUIRED,
            Self::NotAuthorized => ffi::PK_ERROR_ENUM_NOT_AUTHORIZED,
            Self::UpdateNotFound => ffi::PK_ERROR_ENUM_UPDATE_NOT_FOUND,
            Self::CannotInstallRepoUnsigned => ffi::PK_ERROR_ENUM_CANNOT_INSTALL_REPO_UNSIGNED,
            Self::CannotUpdateRepoUnsigned => ffi::PK_ERROR_ENUM_CANNOT_UPDATE_REPO_UNSIGNED,
            Self::CannotGetFilelist => ffi::PK_ERROR_ENUM_CANNOT_GET_FILELIST,
            Self::CannotGetRequires => ffi::PK_ERROR_ENUM_CANNOT_GET_REQUIRES,
            Self::CannotDisableRepository => ffi::PK_ERROR_ENUM_CANNOT_DISABLE_REPOSITORY,
            Self::RestrictedDownload => ffi::PK_ERROR_ENUM_RESTRICTED_DOWNLOAD,
            Self::PackageFailedToConfigure => ffi::PK_ERROR_ENUM_PACKAGE_FAILED_TO_CONFIGURE,
            Self::PackageFailedToBuild => ffi::PK_ERROR_ENUM_PACKAGE_FAILED_TO_BUILD,
            Self::PackageFailedToInstall => ffi::PK_ERROR_ENUM_PACKAGE_FAILED_TO_INSTALL,
            Self::PackageFailedToRemove => ffi::PK_ERROR_ENUM_PACKAGE_FAILED_TO_REMOVE,
            Self::UpdateFailedDueToRunningProcess => ffi::PK_ERROR_ENUM_UPDATE_FAILED_DUE_TO_RUNNING_PROCESS,
            Self::PackageDatabaseChanged => ffi::PK_ERROR_ENUM_PACKAGE_DATABASE_CHANGED,
            Self::ProvideTypeNotSupported => ffi::PK_ERROR_ENUM_PROVIDE_TYPE_NOT_SUPPORTED,
            Self::InstallRootInvalid => ffi::PK_ERROR_ENUM_INSTALL_ROOT_INVALID,
            Self::CannotFetchSources => ffi::PK_ERROR_ENUM_CANNOT_FETCH_SOURCES,
            Self::CancelledPriority => ffi::PK_ERROR_ENUM_CANCELLED_PRIORITY,
            Self::UnfinishedTransaction => ffi::PK_ERROR_ENUM_UNFINISHED_TRANSACTION,
            Self::LockRequired => ffi::PK_ERROR_ENUM_LOCK_REQUIRED,
            Self::RepoAlreadySet => ffi::PK_ERROR_ENUM_REPO_ALREADY_SET,
            Self::Last => ffi::PK_ERROR_ENUM_LAST,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::PkErrorEnum> for ErrorEnum {
    unsafe fn from_glib(value: ffi::PkErrorEnum) -> Self {
        
match value {
            ffi::PK_ERROR_ENUM_UNKNOWN => Self::Unknown,
            ffi::PK_ERROR_ENUM_OOM => Self::Oom,
            ffi::PK_ERROR_ENUM_NO_NETWORK => Self::NoNetwork,
            ffi::PK_ERROR_ENUM_NOT_SUPPORTED => Self::NotSupported,
            ffi::PK_ERROR_ENUM_INTERNAL_ERROR => Self::InternalError,
            ffi::PK_ERROR_ENUM_GPG_FAILURE => Self::GpgFailure,
            ffi::PK_ERROR_ENUM_PACKAGE_ID_INVALID => Self::PackageIdInvalid,
            ffi::PK_ERROR_ENUM_PACKAGE_NOT_INSTALLED => Self::PackageNotInstalled,
            ffi::PK_ERROR_ENUM_PACKAGE_NOT_FOUND => Self::PackageNotFound,
            ffi::PK_ERROR_ENUM_PACKAGE_ALREADY_INSTALLED => Self::PackageAlreadyInstalled,
            ffi::PK_ERROR_ENUM_PACKAGE_DOWNLOAD_FAILED => Self::PackageDownloadFailed,
            ffi::PK_ERROR_ENUM_GROUP_NOT_FOUND => Self::GroupNotFound,
            ffi::PK_ERROR_ENUM_GROUP_LIST_INVALID => Self::GroupListInvalid,
            ffi::PK_ERROR_ENUM_DEP_RESOLUTION_FAILED => Self::DepResolutionFailed,
            ffi::PK_ERROR_ENUM_FILTER_INVALID => Self::FilterInvalid,
            ffi::PK_ERROR_ENUM_CREATE_THREAD_FAILED => Self::CreateThreadFailed,
            ffi::PK_ERROR_ENUM_TRANSACTION_ERROR => Self::TransactionError,
            ffi::PK_ERROR_ENUM_TRANSACTION_CANCELLED => Self::TransactionCancelled,
            ffi::PK_ERROR_ENUM_NO_CACHE => Self::NoCache,
            ffi::PK_ERROR_ENUM_REPO_NOT_FOUND => Self::RepoNotFound,
            ffi::PK_ERROR_ENUM_CANNOT_REMOVE_SYSTEM_PACKAGE => Self::CannotRemoveSystemPackage,
            ffi::PK_ERROR_ENUM_PROCESS_KILL => Self::ProcessKill,
            ffi::PK_ERROR_ENUM_FAILED_INITIALIZATION => Self::FailedInitialization,
            ffi::PK_ERROR_ENUM_FAILED_FINALISE => Self::FailedFinalise,
            ffi::PK_ERROR_ENUM_FAILED_CONFIG_PARSING => Self::FailedConfigParsing,
            ffi::PK_ERROR_ENUM_CANNOT_CANCEL => Self::CannotCancel,
            ffi::PK_ERROR_ENUM_CANNOT_GET_LOCK => Self::CannotGetLock,
            ffi::PK_ERROR_ENUM_NO_PACKAGES_TO_UPDATE => Self::NoPackagesToUpdate,
            ffi::PK_ERROR_ENUM_CANNOT_WRITE_REPO_CONFIG => Self::CannotWriteRepoConfig,
            ffi::PK_ERROR_ENUM_LOCAL_INSTALL_FAILED => Self::LocalInstallFailed,
            ffi::PK_ERROR_ENUM_BAD_GPG_SIGNATURE => Self::BadGpgSignature,
            ffi::PK_ERROR_ENUM_MISSING_GPG_SIGNATURE => Self::MissingGpgSignature,
            ffi::PK_ERROR_ENUM_CANNOT_INSTALL_SOURCE_PACKAGE => Self::CannotInstallSourcePackage,
            ffi::PK_ERROR_ENUM_REPO_CONFIGURATION_ERROR => Self::RepoConfigurationError,
            ffi::PK_ERROR_ENUM_NO_LICENSE_AGREEMENT => Self::NoLicenseAgreement,
            ffi::PK_ERROR_ENUM_FILE_CONFLICTS => Self::FileConflicts,
            ffi::PK_ERROR_ENUM_PACKAGE_CONFLICTS => Self::PackageConflicts,
            ffi::PK_ERROR_ENUM_REPO_NOT_AVAILABLE => Self::RepoNotAvailable,
            ffi::PK_ERROR_ENUM_INVALID_PACKAGE_FILE => Self::InvalidPackageFile,
            ffi::PK_ERROR_ENUM_PACKAGE_INSTALL_BLOCKED => Self::PackageInstallBlocked,
            ffi::PK_ERROR_ENUM_PACKAGE_CORRUPT => Self::PackageCorrupt,
            ffi::PK_ERROR_ENUM_ALL_PACKAGES_ALREADY_INSTALLED => Self::AllPackagesAlreadyInstalled,
            ffi::PK_ERROR_ENUM_FILE_NOT_FOUND => Self::FileNotFound,
            ffi::PK_ERROR_ENUM_NO_MORE_MIRRORS_TO_TRY => Self::NoMoreMirrorsToTry,
            ffi::PK_ERROR_ENUM_NO_DISTRO_UPGRADE_DATA => Self::NoDistroUpgradeData,
            ffi::PK_ERROR_ENUM_INCOMPATIBLE_ARCHITECTURE => Self::IncompatibleArchitecture,
            ffi::PK_ERROR_ENUM_NO_SPACE_ON_DEVICE => Self::NoSpaceOnDevice,
            ffi::PK_ERROR_ENUM_MEDIA_CHANGE_REQUIRED => Self::MediaChangeRequired,
            ffi::PK_ERROR_ENUM_NOT_AUTHORIZED => Self::NotAuthorized,
            ffi::PK_ERROR_ENUM_UPDATE_NOT_FOUND => Self::UpdateNotFound,
            ffi::PK_ERROR_ENUM_CANNOT_INSTALL_REPO_UNSIGNED => Self::CannotInstallRepoUnsigned,
            ffi::PK_ERROR_ENUM_CANNOT_UPDATE_REPO_UNSIGNED => Self::CannotUpdateRepoUnsigned,
            ffi::PK_ERROR_ENUM_CANNOT_GET_FILELIST => Self::CannotGetFilelist,
            ffi::PK_ERROR_ENUM_CANNOT_GET_REQUIRES => Self::CannotGetRequires,
            ffi::PK_ERROR_ENUM_CANNOT_DISABLE_REPOSITORY => Self::CannotDisableRepository,
            ffi::PK_ERROR_ENUM_RESTRICTED_DOWNLOAD => Self::RestrictedDownload,
            ffi::PK_ERROR_ENUM_PACKAGE_FAILED_TO_CONFIGURE => Self::PackageFailedToConfigure,
            ffi::PK_ERROR_ENUM_PACKAGE_FAILED_TO_BUILD => Self::PackageFailedToBuild,
            ffi::PK_ERROR_ENUM_PACKAGE_FAILED_TO_INSTALL => Self::PackageFailedToInstall,
            ffi::PK_ERROR_ENUM_PACKAGE_FAILED_TO_REMOVE => Self::PackageFailedToRemove,
            ffi::PK_ERROR_ENUM_UPDATE_FAILED_DUE_TO_RUNNING_PROCESS => Self::UpdateFailedDueToRunningProcess,
            ffi::PK_ERROR_ENUM_PACKAGE_DATABASE_CHANGED => Self::PackageDatabaseChanged,
            ffi::PK_ERROR_ENUM_PROVIDE_TYPE_NOT_SUPPORTED => Self::ProvideTypeNotSupported,
            ffi::PK_ERROR_ENUM_INSTALL_ROOT_INVALID => Self::InstallRootInvalid,
            ffi::PK_ERROR_ENUM_CANNOT_FETCH_SOURCES => Self::CannotFetchSources,
            ffi::PK_ERROR_ENUM_CANCELLED_PRIORITY => Self::CancelledPriority,
            ffi::PK_ERROR_ENUM_UNFINISHED_TRANSACTION => Self::UnfinishedTransaction,
            ffi::PK_ERROR_ENUM_LOCK_REQUIRED => Self::LockRequired,
            ffi::PK_ERROR_ENUM_REPO_ALREADY_SET => Self::RepoAlreadySet,
            ffi::PK_ERROR_ENUM_LAST => Self::Last,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for ErrorEnum {
                #[inline]
    #[doc(alias = "pk_error_enum_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::pk_error_enum_get_type()) }
                }
            }

impl glib::HasParamSpec for ErrorEnum {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for ErrorEnum {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ErrorEnum {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ErrorEnum {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ErrorEnum> for glib::Value {
    #[inline]
    fn from(v: ErrorEnum) -> Self {
        ToValue::to_value(&v)
    }
}

/// How the backend exited
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PkExitEnum")]
pub enum ExitEnum {
    #[doc(alias = "PK_EXIT_ENUM_UNKNOWN")]
    Unknown,
    #[doc(alias = "PK_EXIT_ENUM_SUCCESS")]
    Success,
    #[doc(alias = "PK_EXIT_ENUM_FAILED")]
    Failed,
    #[doc(alias = "PK_EXIT_ENUM_CANCELLED")]
    Cancelled,
    #[doc(alias = "PK_EXIT_ENUM_KEY_REQUIRED")]
    KeyRequired,
    #[doc(alias = "PK_EXIT_ENUM_EULA_REQUIRED")]
    EulaRequired,
    #[doc(alias = "PK_EXIT_ENUM_KILLED")]
    Killed,
    #[doc(alias = "PK_EXIT_ENUM_MEDIA_CHANGE_REQUIRED")]
    MediaChangeRequired,
    #[doc(alias = "PK_EXIT_ENUM_NEED_UNTRUSTED")]
    NeedUntrusted,
    #[doc(alias = "PK_EXIT_ENUM_CANCELLED_PRIORITY")]
    CancelledPriority,
    #[doc(alias = "PK_EXIT_ENUM_SKIP_TRANSACTION")]
    SkipTransaction,
    #[doc(alias = "PK_EXIT_ENUM_REPAIR_REQUIRED")]
    RepairRequired,
    #[doc(alias = "PK_EXIT_ENUM_LAST")]
    Last,
#[doc(hidden)]
    __Unknown(i32),
}

impl ExitEnum {
    #[cfg(feature = "v0_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
    #[doc(alias = "pk_exit_enum_from_string")]
    pub fn from_string(exit: &str) -> ExitEnum {
        unsafe {
            from_glib(ffi::pk_exit_enum_from_string(exit.to_glib_none().0))
        }
    }

    #[cfg(feature = "v0_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
    #[doc(alias = "pk_exit_enum_to_string")]
    #[doc(alias = "to_string")]
    pub fn to_str(self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::pk_exit_enum_to_string(self.into_glib()))
        }
    }
}

#[doc(hidden)]
impl IntoGlib for ExitEnum {
    type GlibType = ffi::PkExitEnum;

    fn into_glib(self) -> ffi::PkExitEnum {
match self {
            Self::Unknown => ffi::PK_EXIT_ENUM_UNKNOWN,
            Self::Success => ffi::PK_EXIT_ENUM_SUCCESS,
            Self::Failed => ffi::PK_EXIT_ENUM_FAILED,
            Self::Cancelled => ffi::PK_EXIT_ENUM_CANCELLED,
            Self::KeyRequired => ffi::PK_EXIT_ENUM_KEY_REQUIRED,
            Self::EulaRequired => ffi::PK_EXIT_ENUM_EULA_REQUIRED,
            Self::Killed => ffi::PK_EXIT_ENUM_KILLED,
            Self::MediaChangeRequired => ffi::PK_EXIT_ENUM_MEDIA_CHANGE_REQUIRED,
            Self::NeedUntrusted => ffi::PK_EXIT_ENUM_NEED_UNTRUSTED,
            Self::CancelledPriority => ffi::PK_EXIT_ENUM_CANCELLED_PRIORITY,
            Self::SkipTransaction => ffi::PK_EXIT_ENUM_SKIP_TRANSACTION,
            Self::RepairRequired => ffi::PK_EXIT_ENUM_REPAIR_REQUIRED,
            Self::Last => ffi::PK_EXIT_ENUM_LAST,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::PkExitEnum> for ExitEnum {
    unsafe fn from_glib(value: ffi::PkExitEnum) -> Self {
        
match value {
            ffi::PK_EXIT_ENUM_UNKNOWN => Self::Unknown,
            ffi::PK_EXIT_ENUM_SUCCESS => Self::Success,
            ffi::PK_EXIT_ENUM_FAILED => Self::Failed,
            ffi::PK_EXIT_ENUM_CANCELLED => Self::Cancelled,
            ffi::PK_EXIT_ENUM_KEY_REQUIRED => Self::KeyRequired,
            ffi::PK_EXIT_ENUM_EULA_REQUIRED => Self::EulaRequired,
            ffi::PK_EXIT_ENUM_KILLED => Self::Killed,
            ffi::PK_EXIT_ENUM_MEDIA_CHANGE_REQUIRED => Self::MediaChangeRequired,
            ffi::PK_EXIT_ENUM_NEED_UNTRUSTED => Self::NeedUntrusted,
            ffi::PK_EXIT_ENUM_CANCELLED_PRIORITY => Self::CancelledPriority,
            ffi::PK_EXIT_ENUM_SKIP_TRANSACTION => Self::SkipTransaction,
            ffi::PK_EXIT_ENUM_REPAIR_REQUIRED => Self::RepairRequired,
            ffi::PK_EXIT_ENUM_LAST => Self::Last,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for ExitEnum {
                #[inline]
    #[doc(alias = "pk_exit_enum_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::pk_exit_enum_get_type()) }
                }
            }

impl glib::HasParamSpec for ExitEnum {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for ExitEnum {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ExitEnum {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ExitEnum {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ExitEnum> for glib::Value {
    #[inline]
    fn from(v: ExitEnum) -> Self {
        ToValue::to_value(&v)
    }
}

/// The filter types
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PkFilterEnum")]
pub enum FilterEnum {
    #[doc(alias = "PK_FILTER_ENUM_UNKNOWN")]
    Unknown,
    #[doc(alias = "PK_FILTER_ENUM_NONE")]
    None,
    #[doc(alias = "PK_FILTER_ENUM_INSTALLED")]
    Installed,
    #[doc(alias = "PK_FILTER_ENUM_NOT_INSTALLED")]
    NotInstalled,
    #[doc(alias = "PK_FILTER_ENUM_DEVELOPMENT")]
    Development,
    #[doc(alias = "PK_FILTER_ENUM_NOT_DEVELOPMENT")]
    NotDevelopment,
    #[doc(alias = "PK_FILTER_ENUM_GUI")]
    Gui,
    #[doc(alias = "PK_FILTER_ENUM_NOT_GUI")]
    NotGui,
    #[doc(alias = "PK_FILTER_ENUM_FREE")]
    Free,
    #[doc(alias = "PK_FILTER_ENUM_NOT_FREE")]
    NotFree,
    #[doc(alias = "PK_FILTER_ENUM_VISIBLE")]
    Visible,
    #[doc(alias = "PK_FILTER_ENUM_NOT_VISIBLE")]
    NotVisible,
    #[doc(alias = "PK_FILTER_ENUM_SUPPORTED")]
    Supported,
    #[doc(alias = "PK_FILTER_ENUM_NOT_SUPPORTED")]
    NotSupported,
    #[doc(alias = "PK_FILTER_ENUM_BASENAME")]
    Basename,
    #[doc(alias = "PK_FILTER_ENUM_NOT_BASENAME")]
    NotBasename,
    #[doc(alias = "PK_FILTER_ENUM_NEWEST")]
    Newest,
    #[doc(alias = "PK_FILTER_ENUM_NOT_NEWEST")]
    NotNewest,
    #[doc(alias = "PK_FILTER_ENUM_ARCH")]
    Arch,
    #[doc(alias = "PK_FILTER_ENUM_NOT_ARCH")]
    NotArch,
    #[doc(alias = "PK_FILTER_ENUM_SOURCE")]
    Source,
    #[doc(alias = "PK_FILTER_ENUM_NOT_SOURCE")]
    NotSource,
    #[doc(alias = "PK_FILTER_ENUM_COLLECTIONS")]
    Collections,
    #[doc(alias = "PK_FILTER_ENUM_NOT_COLLECTIONS")]
    NotCollections,
    #[doc(alias = "PK_FILTER_ENUM_APPLICATION")]
    Application,
    #[doc(alias = "PK_FILTER_ENUM_NOT_APPLICATION")]
    NotApplication,
    #[doc(alias = "PK_FILTER_ENUM_DOWNLOADED")]
    Downloaded,
    #[doc(alias = "PK_FILTER_ENUM_NOT_DOWNLOADED")]
    NotDownloaded,
    #[doc(alias = "PK_FILTER_ENUM_LAST")]
    Last,
#[doc(hidden)]
    __Unknown(i32),
}

impl FilterEnum {
    #[cfg(feature = "v0_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
    #[doc(alias = "pk_filter_enum_from_string")]
    pub fn from_string(filter: &str) -> FilterEnum {
        unsafe {
            from_glib(ffi::pk_filter_enum_from_string(filter.to_glib_none().0))
        }
    }

    #[cfg(feature = "v0_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
    #[doc(alias = "pk_filter_enum_to_string")]
    #[doc(alias = "to_string")]
    pub fn to_str(self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::pk_filter_enum_to_string(self.into_glib()))
        }
    }
}

#[doc(hidden)]
impl IntoGlib for FilterEnum {
    type GlibType = ffi::PkFilterEnum;

    fn into_glib(self) -> ffi::PkFilterEnum {
match self {
            Self::Unknown => ffi::PK_FILTER_ENUM_UNKNOWN,
            Self::None => ffi::PK_FILTER_ENUM_NONE,
            Self::Installed => ffi::PK_FILTER_ENUM_INSTALLED,
            Self::NotInstalled => ffi::PK_FILTER_ENUM_NOT_INSTALLED,
            Self::Development => ffi::PK_FILTER_ENUM_DEVELOPMENT,
            Self::NotDevelopment => ffi::PK_FILTER_ENUM_NOT_DEVELOPMENT,
            Self::Gui => ffi::PK_FILTER_ENUM_GUI,
            Self::NotGui => ffi::PK_FILTER_ENUM_NOT_GUI,
            Self::Free => ffi::PK_FILTER_ENUM_FREE,
            Self::NotFree => ffi::PK_FILTER_ENUM_NOT_FREE,
            Self::Visible => ffi::PK_FILTER_ENUM_VISIBLE,
            Self::NotVisible => ffi::PK_FILTER_ENUM_NOT_VISIBLE,
            Self::Supported => ffi::PK_FILTER_ENUM_SUPPORTED,
            Self::NotSupported => ffi::PK_FILTER_ENUM_NOT_SUPPORTED,
            Self::Basename => ffi::PK_FILTER_ENUM_BASENAME,
            Self::NotBasename => ffi::PK_FILTER_ENUM_NOT_BASENAME,
            Self::Newest => ffi::PK_FILTER_ENUM_NEWEST,
            Self::NotNewest => ffi::PK_FILTER_ENUM_NOT_NEWEST,
            Self::Arch => ffi::PK_FILTER_ENUM_ARCH,
            Self::NotArch => ffi::PK_FILTER_ENUM_NOT_ARCH,
            Self::Source => ffi::PK_FILTER_ENUM_SOURCE,
            Self::NotSource => ffi::PK_FILTER_ENUM_NOT_SOURCE,
            Self::Collections => ffi::PK_FILTER_ENUM_COLLECTIONS,
            Self::NotCollections => ffi::PK_FILTER_ENUM_NOT_COLLECTIONS,
            Self::Application => ffi::PK_FILTER_ENUM_APPLICATION,
            Self::NotApplication => ffi::PK_FILTER_ENUM_NOT_APPLICATION,
            Self::Downloaded => ffi::PK_FILTER_ENUM_DOWNLOADED,
            Self::NotDownloaded => ffi::PK_FILTER_ENUM_NOT_DOWNLOADED,
            Self::Last => ffi::PK_FILTER_ENUM_LAST,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::PkFilterEnum> for FilterEnum {
    unsafe fn from_glib(value: ffi::PkFilterEnum) -> Self {
        
match value {
            ffi::PK_FILTER_ENUM_UNKNOWN => Self::Unknown,
            ffi::PK_FILTER_ENUM_NONE => Self::None,
            ffi::PK_FILTER_ENUM_INSTALLED => Self::Installed,
            ffi::PK_FILTER_ENUM_NOT_INSTALLED => Self::NotInstalled,
            ffi::PK_FILTER_ENUM_DEVELOPMENT => Self::Development,
            ffi::PK_FILTER_ENUM_NOT_DEVELOPMENT => Self::NotDevelopment,
            ffi::PK_FILTER_ENUM_GUI => Self::Gui,
            ffi::PK_FILTER_ENUM_NOT_GUI => Self::NotGui,
            ffi::PK_FILTER_ENUM_FREE => Self::Free,
            ffi::PK_FILTER_ENUM_NOT_FREE => Self::NotFree,
            ffi::PK_FILTER_ENUM_VISIBLE => Self::Visible,
            ffi::PK_FILTER_ENUM_NOT_VISIBLE => Self::NotVisible,
            ffi::PK_FILTER_ENUM_SUPPORTED => Self::Supported,
            ffi::PK_FILTER_ENUM_NOT_SUPPORTED => Self::NotSupported,
            ffi::PK_FILTER_ENUM_BASENAME => Self::Basename,
            ffi::PK_FILTER_ENUM_NOT_BASENAME => Self::NotBasename,
            ffi::PK_FILTER_ENUM_NEWEST => Self::Newest,
            ffi::PK_FILTER_ENUM_NOT_NEWEST => Self::NotNewest,
            ffi::PK_FILTER_ENUM_ARCH => Self::Arch,
            ffi::PK_FILTER_ENUM_NOT_ARCH => Self::NotArch,
            ffi::PK_FILTER_ENUM_SOURCE => Self::Source,
            ffi::PK_FILTER_ENUM_NOT_SOURCE => Self::NotSource,
            ffi::PK_FILTER_ENUM_COLLECTIONS => Self::Collections,
            ffi::PK_FILTER_ENUM_NOT_COLLECTIONS => Self::NotCollections,
            ffi::PK_FILTER_ENUM_APPLICATION => Self::Application,
            ffi::PK_FILTER_ENUM_NOT_APPLICATION => Self::NotApplication,
            ffi::PK_FILTER_ENUM_DOWNLOADED => Self::Downloaded,
            ffi::PK_FILTER_ENUM_NOT_DOWNLOADED => Self::NotDownloaded,
            ffi::PK_FILTER_ENUM_LAST => Self::Last,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for FilterEnum {
                #[inline]
    #[doc(alias = "pk_filter_enum_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::pk_filter_enum_get_type()) }
                }
            }

impl glib::HasParamSpec for FilterEnum {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for FilterEnum {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for FilterEnum {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for FilterEnum {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<FilterEnum> for glib::Value {
    #[inline]
    fn from(v: FilterEnum) -> Self {
        ToValue::to_value(&v)
    }
}

/// The group type
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PkGroupEnum")]
pub enum GroupEnum {
    #[doc(alias = "PK_GROUP_ENUM_UNKNOWN")]
    Unknown,
    #[doc(alias = "PK_GROUP_ENUM_ACCESSIBILITY")]
    Accessibility,
    #[doc(alias = "PK_GROUP_ENUM_ACCESSORIES")]
    Accessories,
    #[doc(alias = "PK_GROUP_ENUM_ADMIN_TOOLS")]
    AdminTools,
    #[doc(alias = "PK_GROUP_ENUM_COMMUNICATION")]
    Communication,
    #[doc(alias = "PK_GROUP_ENUM_DESKTOP_GNOME")]
    DesktopGnome,
    #[doc(alias = "PK_GROUP_ENUM_DESKTOP_KDE")]
    DesktopKde,
    #[doc(alias = "PK_GROUP_ENUM_DESKTOP_OTHER")]
    DesktopOther,
    #[doc(alias = "PK_GROUP_ENUM_DESKTOP_XFCE")]
    DesktopXfce,
    #[doc(alias = "PK_GROUP_ENUM_EDUCATION")]
    Education,
    #[doc(alias = "PK_GROUP_ENUM_FONTS")]
    Fonts,
    #[doc(alias = "PK_GROUP_ENUM_GAMES")]
    Games,
    #[doc(alias = "PK_GROUP_ENUM_GRAPHICS")]
    Graphics,
    #[doc(alias = "PK_GROUP_ENUM_INTERNET")]
    Internet,
    #[doc(alias = "PK_GROUP_ENUM_LEGACY")]
    Legacy,
    #[doc(alias = "PK_GROUP_ENUM_LOCALIZATION")]
    Localization,
    #[doc(alias = "PK_GROUP_ENUM_MAPS")]
    Maps,
    #[doc(alias = "PK_GROUP_ENUM_MULTIMEDIA")]
    Multimedia,
    #[doc(alias = "PK_GROUP_ENUM_NETWORK")]
    Network,
    #[doc(alias = "PK_GROUP_ENUM_OFFICE")]
    Office,
    #[doc(alias = "PK_GROUP_ENUM_OTHER")]
    Other,
    #[doc(alias = "PK_GROUP_ENUM_POWER_MANAGEMENT")]
    PowerManagement,
    #[doc(alias = "PK_GROUP_ENUM_PROGRAMMING")]
    Programming,
    #[doc(alias = "PK_GROUP_ENUM_PUBLISHING")]
    Publishing,
    #[doc(alias = "PK_GROUP_ENUM_REPOS")]
    Repos,
    #[doc(alias = "PK_GROUP_ENUM_SECURITY")]
    Security,
    #[doc(alias = "PK_GROUP_ENUM_SERVERS")]
    Servers,
    #[doc(alias = "PK_GROUP_ENUM_SYSTEM")]
    System,
    #[doc(alias = "PK_GROUP_ENUM_VIRTUALIZATION")]
    Virtualization,
    #[doc(alias = "PK_GROUP_ENUM_SCIENCE")]
    Science,
    #[doc(alias = "PK_GROUP_ENUM_DOCUMENTATION")]
    Documentation,
    #[doc(alias = "PK_GROUP_ENUM_ELECTRONICS")]
    Electronics,
    #[doc(alias = "PK_GROUP_ENUM_COLLECTIONS")]
    Collections,
    #[doc(alias = "PK_GROUP_ENUM_VENDOR")]
    Vendor,
    #[doc(alias = "PK_GROUP_ENUM_NEWEST")]
    Newest,
    #[doc(alias = "PK_GROUP_ENUM_LAST")]
    Last,
#[doc(hidden)]
    __Unknown(i32),
}

impl GroupEnum {
    #[cfg(feature = "v0_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
    #[doc(alias = "pk_group_enum_from_string")]
    pub fn from_string(group: &str) -> GroupEnum {
        unsafe {
            from_glib(ffi::pk_group_enum_from_string(group.to_glib_none().0))
        }
    }

    #[cfg(feature = "v0_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
    #[doc(alias = "pk_group_enum_to_string")]
    #[doc(alias = "to_string")]
    pub fn to_str(self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::pk_group_enum_to_string(self.into_glib()))
        }
    }
}

#[doc(hidden)]
impl IntoGlib for GroupEnum {
    type GlibType = ffi::PkGroupEnum;

    fn into_glib(self) -> ffi::PkGroupEnum {
match self {
            Self::Unknown => ffi::PK_GROUP_ENUM_UNKNOWN,
            Self::Accessibility => ffi::PK_GROUP_ENUM_ACCESSIBILITY,
            Self::Accessories => ffi::PK_GROUP_ENUM_ACCESSORIES,
            Self::AdminTools => ffi::PK_GROUP_ENUM_ADMIN_TOOLS,
            Self::Communication => ffi::PK_GROUP_ENUM_COMMUNICATION,
            Self::DesktopGnome => ffi::PK_GROUP_ENUM_DESKTOP_GNOME,
            Self::DesktopKde => ffi::PK_GROUP_ENUM_DESKTOP_KDE,
            Self::DesktopOther => ffi::PK_GROUP_ENUM_DESKTOP_OTHER,
            Self::DesktopXfce => ffi::PK_GROUP_ENUM_DESKTOP_XFCE,
            Self::Education => ffi::PK_GROUP_ENUM_EDUCATION,
            Self::Fonts => ffi::PK_GROUP_ENUM_FONTS,
            Self::Games => ffi::PK_GROUP_ENUM_GAMES,
            Self::Graphics => ffi::PK_GROUP_ENUM_GRAPHICS,
            Self::Internet => ffi::PK_GROUP_ENUM_INTERNET,
            Self::Legacy => ffi::PK_GROUP_ENUM_LEGACY,
            Self::Localization => ffi::PK_GROUP_ENUM_LOCALIZATION,
            Self::Maps => ffi::PK_GROUP_ENUM_MAPS,
            Self::Multimedia => ffi::PK_GROUP_ENUM_MULTIMEDIA,
            Self::Network => ffi::PK_GROUP_ENUM_NETWORK,
            Self::Office => ffi::PK_GROUP_ENUM_OFFICE,
            Self::Other => ffi::PK_GROUP_ENUM_OTHER,
            Self::PowerManagement => ffi::PK_GROUP_ENUM_POWER_MANAGEMENT,
            Self::Programming => ffi::PK_GROUP_ENUM_PROGRAMMING,
            Self::Publishing => ffi::PK_GROUP_ENUM_PUBLISHING,
            Self::Repos => ffi::PK_GROUP_ENUM_REPOS,
            Self::Security => ffi::PK_GROUP_ENUM_SECURITY,
            Self::Servers => ffi::PK_GROUP_ENUM_SERVERS,
            Self::System => ffi::PK_GROUP_ENUM_SYSTEM,
            Self::Virtualization => ffi::PK_GROUP_ENUM_VIRTUALIZATION,
            Self::Science => ffi::PK_GROUP_ENUM_SCIENCE,
            Self::Documentation => ffi::PK_GROUP_ENUM_DOCUMENTATION,
            Self::Electronics => ffi::PK_GROUP_ENUM_ELECTRONICS,
            Self::Collections => ffi::PK_GROUP_ENUM_COLLECTIONS,
            Self::Vendor => ffi::PK_GROUP_ENUM_VENDOR,
            Self::Newest => ffi::PK_GROUP_ENUM_NEWEST,
            Self::Last => ffi::PK_GROUP_ENUM_LAST,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::PkGroupEnum> for GroupEnum {
    unsafe fn from_glib(value: ffi::PkGroupEnum) -> Self {
        
match value {
            ffi::PK_GROUP_ENUM_UNKNOWN => Self::Unknown,
            ffi::PK_GROUP_ENUM_ACCESSIBILITY => Self::Accessibility,
            ffi::PK_GROUP_ENUM_ACCESSORIES => Self::Accessories,
            ffi::PK_GROUP_ENUM_ADMIN_TOOLS => Self::AdminTools,
            ffi::PK_GROUP_ENUM_COMMUNICATION => Self::Communication,
            ffi::PK_GROUP_ENUM_DESKTOP_GNOME => Self::DesktopGnome,
            ffi::PK_GROUP_ENUM_DESKTOP_KDE => Self::DesktopKde,
            ffi::PK_GROUP_ENUM_DESKTOP_OTHER => Self::DesktopOther,
            ffi::PK_GROUP_ENUM_DESKTOP_XFCE => Self::DesktopXfce,
            ffi::PK_GROUP_ENUM_EDUCATION => Self::Education,
            ffi::PK_GROUP_ENUM_FONTS => Self::Fonts,
            ffi::PK_GROUP_ENUM_GAMES => Self::Games,
            ffi::PK_GROUP_ENUM_GRAPHICS => Self::Graphics,
            ffi::PK_GROUP_ENUM_INTERNET => Self::Internet,
            ffi::PK_GROUP_ENUM_LEGACY => Self::Legacy,
            ffi::PK_GROUP_ENUM_LOCALIZATION => Self::Localization,
            ffi::PK_GROUP_ENUM_MAPS => Self::Maps,
            ffi::PK_GROUP_ENUM_MULTIMEDIA => Self::Multimedia,
            ffi::PK_GROUP_ENUM_NETWORK => Self::Network,
            ffi::PK_GROUP_ENUM_OFFICE => Self::Office,
            ffi::PK_GROUP_ENUM_OTHER => Self::Other,
            ffi::PK_GROUP_ENUM_POWER_MANAGEMENT => Self::PowerManagement,
            ffi::PK_GROUP_ENUM_PROGRAMMING => Self::Programming,
            ffi::PK_GROUP_ENUM_PUBLISHING => Self::Publishing,
            ffi::PK_GROUP_ENUM_REPOS => Self::Repos,
            ffi::PK_GROUP_ENUM_SECURITY => Self::Security,
            ffi::PK_GROUP_ENUM_SERVERS => Self::Servers,
            ffi::PK_GROUP_ENUM_SYSTEM => Self::System,
            ffi::PK_GROUP_ENUM_VIRTUALIZATION => Self::Virtualization,
            ffi::PK_GROUP_ENUM_SCIENCE => Self::Science,
            ffi::PK_GROUP_ENUM_DOCUMENTATION => Self::Documentation,
            ffi::PK_GROUP_ENUM_ELECTRONICS => Self::Electronics,
            ffi::PK_GROUP_ENUM_COLLECTIONS => Self::Collections,
            ffi::PK_GROUP_ENUM_VENDOR => Self::Vendor,
            ffi::PK_GROUP_ENUM_NEWEST => Self::Newest,
            ffi::PK_GROUP_ENUM_LAST => Self::Last,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for GroupEnum {
                #[inline]
    #[doc(alias = "pk_group_enum_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::pk_group_enum_get_type()) }
                }
            }

impl glib::HasParamSpec for GroupEnum {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for GroupEnum {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for GroupEnum {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for GroupEnum {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<GroupEnum> for glib::Value {
    #[inline]
    fn from(v: GroupEnum) -> Self {
        ToValue::to_value(&v)
    }
}

/// The enumerated types used in Package() - these have to refer to a specific
/// package action, rather than a general state
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PkInfoEnum")]
pub enum InfoEnum {
    #[doc(alias = "PK_INFO_ENUM_UNKNOWN")]
    Unknown,
    #[doc(alias = "PK_INFO_ENUM_INSTALLED")]
    Installed,
    #[doc(alias = "PK_INFO_ENUM_AVAILABLE")]
    Available,
    #[doc(alias = "PK_INFO_ENUM_LOW")]
    Low,
    #[doc(alias = "PK_INFO_ENUM_ENHANCEMENT")]
    Enhancement,
    #[doc(alias = "PK_INFO_ENUM_NORMAL")]
    Normal,
    #[doc(alias = "PK_INFO_ENUM_BUGFIX")]
    Bugfix,
    #[doc(alias = "PK_INFO_ENUM_IMPORTANT")]
    Important,
    #[doc(alias = "PK_INFO_ENUM_SECURITY")]
    Security,
    #[doc(alias = "PK_INFO_ENUM_BLOCKED")]
    Blocked,
    #[doc(alias = "PK_INFO_ENUM_DOWNLOADING")]
    Downloading,
    #[doc(alias = "PK_INFO_ENUM_UPDATING")]
    Updating,
    #[doc(alias = "PK_INFO_ENUM_INSTALLING")]
    Installing,
    #[doc(alias = "PK_INFO_ENUM_REMOVING")]
    Removing,
    #[doc(alias = "PK_INFO_ENUM_CLEANUP")]
    Cleanup,
    #[doc(alias = "PK_INFO_ENUM_OBSOLETING")]
    Obsoleting,
    #[doc(alias = "PK_INFO_ENUM_COLLECTION_INSTALLED")]
    CollectionInstalled,
    #[doc(alias = "PK_INFO_ENUM_COLLECTION_AVAILABLE")]
    CollectionAvailable,
    #[doc(alias = "PK_INFO_ENUM_FINISHED")]
    Finished,
    #[doc(alias = "PK_INFO_ENUM_REINSTALLING")]
    Reinstalling,
    #[doc(alias = "PK_INFO_ENUM_DOWNGRADING")]
    Downgrading,
    #[doc(alias = "PK_INFO_ENUM_PREPARING")]
    Preparing,
    #[doc(alias = "PK_INFO_ENUM_DECOMPRESSING")]
    Decompressing,
    #[doc(alias = "PK_INFO_ENUM_UNTRUSTED")]
    Untrusted,
    #[doc(alias = "PK_INFO_ENUM_TRUSTED")]
    Trusted,
    #[doc(alias = "PK_INFO_ENUM_UNAVAILABLE")]
    Unavailable,
    #[doc(alias = "PK_INFO_ENUM_CRITICAL")]
    Critical,
    #[doc(alias = "PK_INFO_ENUM_LAST")]
    Last,
#[doc(hidden)]
    __Unknown(i32),
}

impl InfoEnum {
    #[cfg(feature = "v0_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
    #[doc(alias = "pk_info_enum_from_string")]
    pub fn from_string(info: &str) -> InfoEnum {
        unsafe {
            from_glib(ffi::pk_info_enum_from_string(info.to_glib_none().0))
        }
    }

    #[cfg(feature = "v0_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_7_2")))]
    #[doc(alias = "pk_info_enum_to_localised_past")]
    pub fn to_localised_past(self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::pk_info_enum_to_localised_past(self.into_glib()))
        }
    }

    #[cfg(feature = "v0_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_7_2")))]
    #[doc(alias = "pk_info_enum_to_localised_present")]
    pub fn to_localised_present(self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::pk_info_enum_to_localised_present(self.into_glib()))
        }
    }

    #[cfg(feature = "v0_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
    #[doc(alias = "pk_info_enum_to_string")]
    #[doc(alias = "to_string")]
    pub fn to_str(self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::pk_info_enum_to_string(self.into_glib()))
        }
    }
}

#[doc(hidden)]
impl IntoGlib for InfoEnum {
    type GlibType = ffi::PkInfoEnum;

    fn into_glib(self) -> ffi::PkInfoEnum {
match self {
            Self::Unknown => ffi::PK_INFO_ENUM_UNKNOWN,
            Self::Installed => ffi::PK_INFO_ENUM_INSTALLED,
            Self::Available => ffi::PK_INFO_ENUM_AVAILABLE,
            Self::Low => ffi::PK_INFO_ENUM_LOW,
            Self::Enhancement => ffi::PK_INFO_ENUM_ENHANCEMENT,
            Self::Normal => ffi::PK_INFO_ENUM_NORMAL,
            Self::Bugfix => ffi::PK_INFO_ENUM_BUGFIX,
            Self::Important => ffi::PK_INFO_ENUM_IMPORTANT,
            Self::Security => ffi::PK_INFO_ENUM_SECURITY,
            Self::Blocked => ffi::PK_INFO_ENUM_BLOCKED,
            Self::Downloading => ffi::PK_INFO_ENUM_DOWNLOADING,
            Self::Updating => ffi::PK_INFO_ENUM_UPDATING,
            Self::Installing => ffi::PK_INFO_ENUM_INSTALLING,
            Self::Removing => ffi::PK_INFO_ENUM_REMOVING,
            Self::Cleanup => ffi::PK_INFO_ENUM_CLEANUP,
            Self::Obsoleting => ffi::PK_INFO_ENUM_OBSOLETING,
            Self::CollectionInstalled => ffi::PK_INFO_ENUM_COLLECTION_INSTALLED,
            Self::CollectionAvailable => ffi::PK_INFO_ENUM_COLLECTION_AVAILABLE,
            Self::Finished => ffi::PK_INFO_ENUM_FINISHED,
            Self::Reinstalling => ffi::PK_INFO_ENUM_REINSTALLING,
            Self::Downgrading => ffi::PK_INFO_ENUM_DOWNGRADING,
            Self::Preparing => ffi::PK_INFO_ENUM_PREPARING,
            Self::Decompressing => ffi::PK_INFO_ENUM_DECOMPRESSING,
            Self::Untrusted => ffi::PK_INFO_ENUM_UNTRUSTED,
            Self::Trusted => ffi::PK_INFO_ENUM_TRUSTED,
            Self::Unavailable => ffi::PK_INFO_ENUM_UNAVAILABLE,
            Self::Critical => ffi::PK_INFO_ENUM_CRITICAL,
            Self::Last => ffi::PK_INFO_ENUM_LAST,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::PkInfoEnum> for InfoEnum {
    unsafe fn from_glib(value: ffi::PkInfoEnum) -> Self {
        
match value {
            ffi::PK_INFO_ENUM_UNKNOWN => Self::Unknown,
            ffi::PK_INFO_ENUM_INSTALLED => Self::Installed,
            ffi::PK_INFO_ENUM_AVAILABLE => Self::Available,
            ffi::PK_INFO_ENUM_LOW => Self::Low,
            ffi::PK_INFO_ENUM_ENHANCEMENT => Self::Enhancement,
            ffi::PK_INFO_ENUM_NORMAL => Self::Normal,
            ffi::PK_INFO_ENUM_BUGFIX => Self::Bugfix,
            ffi::PK_INFO_ENUM_IMPORTANT => Self::Important,
            ffi::PK_INFO_ENUM_SECURITY => Self::Security,
            ffi::PK_INFO_ENUM_BLOCKED => Self::Blocked,
            ffi::PK_INFO_ENUM_DOWNLOADING => Self::Downloading,
            ffi::PK_INFO_ENUM_UPDATING => Self::Updating,
            ffi::PK_INFO_ENUM_INSTALLING => Self::Installing,
            ffi::PK_INFO_ENUM_REMOVING => Self::Removing,
            ffi::PK_INFO_ENUM_CLEANUP => Self::Cleanup,
            ffi::PK_INFO_ENUM_OBSOLETING => Self::Obsoleting,
            ffi::PK_INFO_ENUM_COLLECTION_INSTALLED => Self::CollectionInstalled,
            ffi::PK_INFO_ENUM_COLLECTION_AVAILABLE => Self::CollectionAvailable,
            ffi::PK_INFO_ENUM_FINISHED => Self::Finished,
            ffi::PK_INFO_ENUM_REINSTALLING => Self::Reinstalling,
            ffi::PK_INFO_ENUM_DOWNGRADING => Self::Downgrading,
            ffi::PK_INFO_ENUM_PREPARING => Self::Preparing,
            ffi::PK_INFO_ENUM_DECOMPRESSING => Self::Decompressing,
            ffi::PK_INFO_ENUM_UNTRUSTED => Self::Untrusted,
            ffi::PK_INFO_ENUM_TRUSTED => Self::Trusted,
            ffi::PK_INFO_ENUM_UNAVAILABLE => Self::Unavailable,
            ffi::PK_INFO_ENUM_CRITICAL => Self::Critical,
            ffi::PK_INFO_ENUM_LAST => Self::Last,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for InfoEnum {
                #[inline]
    #[doc(alias = "pk_info_enum_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::pk_info_enum_get_type()) }
                }
            }

impl glib::HasParamSpec for InfoEnum {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for InfoEnum {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for InfoEnum {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for InfoEnum {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<InfoEnum> for glib::Value {
    #[inline]
    fn from(v: InfoEnum) -> Self {
        ToValue::to_value(&v)
    }
}

/// The media type
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PkMediaTypeEnum")]
pub enum MediaTypeEnum {
    #[doc(alias = "PK_MEDIA_TYPE_ENUM_UNKNOWN")]
    Unknown,
    #[doc(alias = "PK_MEDIA_TYPE_ENUM_CD")]
    Cd,
    #[doc(alias = "PK_MEDIA_TYPE_ENUM_DVD")]
    Dvd,
    #[doc(alias = "PK_MEDIA_TYPE_ENUM_DISC")]
    Disc,
    #[doc(alias = "PK_MEDIA_TYPE_ENUM_LAST")]
    Last,
#[doc(hidden)]
    __Unknown(i32),
}

impl MediaTypeEnum {
    #[cfg(feature = "v0_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
    #[doc(alias = "pk_media_type_enum_from_string")]
    pub fn from_string(media_type: &str) -> MediaTypeEnum {
        unsafe {
            from_glib(ffi::pk_media_type_enum_from_string(media_type.to_glib_none().0))
        }
    }

    #[cfg(feature = "v0_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
    #[doc(alias = "pk_media_type_enum_to_string")]
    #[doc(alias = "to_string")]
    pub fn to_str(self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::pk_media_type_enum_to_string(self.into_glib()))
        }
    }
}

#[doc(hidden)]
impl IntoGlib for MediaTypeEnum {
    type GlibType = ffi::PkMediaTypeEnum;

    #[inline]
fn into_glib(self) -> ffi::PkMediaTypeEnum {
match self {
            Self::Unknown => ffi::PK_MEDIA_TYPE_ENUM_UNKNOWN,
            Self::Cd => ffi::PK_MEDIA_TYPE_ENUM_CD,
            Self::Dvd => ffi::PK_MEDIA_TYPE_ENUM_DVD,
            Self::Disc => ffi::PK_MEDIA_TYPE_ENUM_DISC,
            Self::Last => ffi::PK_MEDIA_TYPE_ENUM_LAST,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::PkMediaTypeEnum> for MediaTypeEnum {
    #[inline]
unsafe fn from_glib(value: ffi::PkMediaTypeEnum) -> Self {
        
match value {
            ffi::PK_MEDIA_TYPE_ENUM_UNKNOWN => Self::Unknown,
            ffi::PK_MEDIA_TYPE_ENUM_CD => Self::Cd,
            ffi::PK_MEDIA_TYPE_ENUM_DVD => Self::Dvd,
            ffi::PK_MEDIA_TYPE_ENUM_DISC => Self::Disc,
            ffi::PK_MEDIA_TYPE_ENUM_LAST => Self::Last,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for MediaTypeEnum {
                #[inline]
    #[doc(alias = "pk_media_type_enum_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::pk_media_type_enum_get_type()) }
                }
            }

impl glib::HasParamSpec for MediaTypeEnum {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for MediaTypeEnum {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for MediaTypeEnum {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for MediaTypeEnum {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<MediaTypeEnum> for glib::Value {
    #[inline]
    fn from(v: MediaTypeEnum) -> Self {
        ToValue::to_value(&v)
    }
}

/// Network type
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PkNetworkEnum")]
pub enum NetworkEnum {
    #[doc(alias = "PK_NETWORK_ENUM_UNKNOWN")]
    Unknown,
    #[doc(alias = "PK_NETWORK_ENUM_OFFLINE")]
    Offline,
    #[doc(alias = "PK_NETWORK_ENUM_ONLINE")]
    Online,
    #[doc(alias = "PK_NETWORK_ENUM_WIRED")]
    Wired,
    #[doc(alias = "PK_NETWORK_ENUM_WIFI")]
    Wifi,
    #[doc(alias = "PK_NETWORK_ENUM_MOBILE")]
    Mobile,
    #[doc(alias = "PK_NETWORK_ENUM_LAST")]
    Last,
#[doc(hidden)]
    __Unknown(i32),
}

impl NetworkEnum {
    #[cfg(feature = "v0_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
    #[doc(alias = "pk_network_enum_from_string")]
    pub fn from_string(network: &str) -> NetworkEnum {
        unsafe {
            from_glib(ffi::pk_network_enum_from_string(network.to_glib_none().0))
        }
    }

    #[cfg(feature = "v0_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
    #[doc(alias = "pk_network_enum_to_string")]
    #[doc(alias = "to_string")]
    pub fn to_str(self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::pk_network_enum_to_string(self.into_glib()))
        }
    }
}

#[doc(hidden)]
impl IntoGlib for NetworkEnum {
    type GlibType = ffi::PkNetworkEnum;

    #[inline]
fn into_glib(self) -> ffi::PkNetworkEnum {
match self {
            Self::Unknown => ffi::PK_NETWORK_ENUM_UNKNOWN,
            Self::Offline => ffi::PK_NETWORK_ENUM_OFFLINE,
            Self::Online => ffi::PK_NETWORK_ENUM_ONLINE,
            Self::Wired => ffi::PK_NETWORK_ENUM_WIRED,
            Self::Wifi => ffi::PK_NETWORK_ENUM_WIFI,
            Self::Mobile => ffi::PK_NETWORK_ENUM_MOBILE,
            Self::Last => ffi::PK_NETWORK_ENUM_LAST,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::PkNetworkEnum> for NetworkEnum {
    #[inline]
unsafe fn from_glib(value: ffi::PkNetworkEnum) -> Self {
        
match value {
            ffi::PK_NETWORK_ENUM_UNKNOWN => Self::Unknown,
            ffi::PK_NETWORK_ENUM_OFFLINE => Self::Offline,
            ffi::PK_NETWORK_ENUM_ONLINE => Self::Online,
            ffi::PK_NETWORK_ENUM_WIRED => Self::Wired,
            ffi::PK_NETWORK_ENUM_WIFI => Self::Wifi,
            ffi::PK_NETWORK_ENUM_MOBILE => Self::Mobile,
            ffi::PK_NETWORK_ENUM_LAST => Self::Last,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for NetworkEnum {
                #[inline]
    #[doc(alias = "pk_network_enum_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::pk_network_enum_get_type()) }
                }
            }

impl glib::HasParamSpec for NetworkEnum {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for NetworkEnum {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for NetworkEnum {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for NetworkEnum {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<NetworkEnum> for glib::Value {
    #[inline]
    fn from(v: NetworkEnum) -> Self {
        ToValue::to_value(&v)
    }
}

/// Actions that can be taken after an offline operation.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PkOfflineAction")]
pub enum OfflineAction {
    #[doc(alias = "PK_OFFLINE_ACTION_UNKNOWN")]
    Unknown,
    #[doc(alias = "PK_OFFLINE_ACTION_REBOOT")]
    Reboot,
    #[doc(alias = "PK_OFFLINE_ACTION_POWER_OFF")]
    PowerOff,
    #[doc(alias = "PK_OFFLINE_ACTION_UNSET")]
    Unset,
#[doc(hidden)]
    __Unknown(i32),
}

impl OfflineAction {
    #[cfg(feature = "v0_9_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_9_6")))]
    #[doc(alias = "pk_offline_action_from_string")]
    pub fn from_string(action: &str) -> OfflineAction {
        unsafe {
            from_glib(ffi::pk_offline_action_from_string(action.to_glib_none().0))
        }
    }

    #[cfg(feature = "v0_9_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_9_6")))]
    #[doc(alias = "pk_offline_action_to_string")]
    #[doc(alias = "to_string")]
    pub fn to_str(self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::pk_offline_action_to_string(self.into_glib()))
        }
    }
}

#[doc(hidden)]
impl IntoGlib for OfflineAction {
    type GlibType = ffi::PkOfflineAction;

    #[inline]
fn into_glib(self) -> ffi::PkOfflineAction {
match self {
            Self::Unknown => ffi::PK_OFFLINE_ACTION_UNKNOWN,
            Self::Reboot => ffi::PK_OFFLINE_ACTION_REBOOT,
            Self::PowerOff => ffi::PK_OFFLINE_ACTION_POWER_OFF,
            Self::Unset => ffi::PK_OFFLINE_ACTION_UNSET,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::PkOfflineAction> for OfflineAction {
    #[inline]
unsafe fn from_glib(value: ffi::PkOfflineAction) -> Self {
        
match value {
            ffi::PK_OFFLINE_ACTION_UNKNOWN => Self::Unknown,
            ffi::PK_OFFLINE_ACTION_REBOOT => Self::Reboot,
            ffi::PK_OFFLINE_ACTION_POWER_OFF => Self::PowerOff,
            ffi::PK_OFFLINE_ACTION_UNSET => Self::Unset,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for OfflineAction {
                #[inline]
    #[doc(alias = "pk_offline_action_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::pk_offline_action_get_type()) }
                }
            }

impl glib::HasParamSpec for OfflineAction {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for OfflineAction {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for OfflineAction {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for OfflineAction {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<OfflineAction> for glib::Value {
    #[inline]
    fn from(v: OfflineAction) -> Self {
        ToValue::to_value(&v)
    }
}

/// Errors that can be thrown
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PkOfflineError")]
pub enum OfflineError {
    #[doc(alias = "PK_OFFLINE_ERROR_FAILED")]
    Failed,
    #[doc(alias = "PK_OFFLINE_ERROR_INVALID_VALUE")]
    InvalidValue,
    #[doc(alias = "PK_OFFLINE_ERROR_NO_DATA")]
    NoData,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for OfflineError {
    type GlibType = ffi::PkOfflineError;

    #[inline]
fn into_glib(self) -> ffi::PkOfflineError {
match self {
            Self::Failed => ffi::PK_OFFLINE_ERROR_FAILED,
            Self::InvalidValue => ffi::PK_OFFLINE_ERROR_INVALID_VALUE,
            Self::NoData => ffi::PK_OFFLINE_ERROR_NO_DATA,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::PkOfflineError> for OfflineError {
    #[inline]
unsafe fn from_glib(value: ffi::PkOfflineError) -> Self {
        
match value {
            ffi::PK_OFFLINE_ERROR_FAILED => Self::Failed,
            ffi::PK_OFFLINE_ERROR_INVALID_VALUE => Self::InvalidValue,
            ffi::PK_OFFLINE_ERROR_NO_DATA => Self::NoData,
            value => Self::__Unknown(value),
}
}
}

impl glib::error::ErrorDomain for OfflineError {
    #[inline]
    fn domain() -> glib::Quark {
        
        unsafe { from_glib(ffi::pk_offline_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        match unsafe { from_glib(code) } {
            Self::__Unknown(_) => Some(Self::Failed),
            value => Some(value),
}
    }
}

impl StaticType for OfflineError {
                #[inline]
    #[doc(alias = "pk_offline_error_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::pk_offline_error_get_type()) }
                }
            }

impl glib::HasParamSpec for OfflineError {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for OfflineError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for OfflineError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for OfflineError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<OfflineError> for glib::Value {
    #[inline]
    fn from(v: OfflineError) -> Self {
        ToValue::to_value(&v)
    }
}

/// Type of sort to perform.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PkPackageSackSortType")]
pub enum PackageSackSortType {
    #[doc(alias = "PK_PACKAGE_SACK_SORT_TYPE_NAME")]
    Name,
    #[doc(alias = "PK_PACKAGE_SACK_SORT_TYPE_INFO")]
    Info,
    #[doc(alias = "PK_PACKAGE_SACK_SORT_TYPE_PACKAGE_ID")]
    PackageId,
    #[doc(alias = "PK_PACKAGE_SACK_SORT_TYPE_SUMMARY")]
    Summary,
    #[doc(alias = "PK_PACKAGE_SACK_SORT_TYPE_LAST")]
    Last,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for PackageSackSortType {
    type GlibType = ffi::PkPackageSackSortType;

    #[inline]
fn into_glib(self) -> ffi::PkPackageSackSortType {
match self {
            Self::Name => ffi::PK_PACKAGE_SACK_SORT_TYPE_NAME,
            Self::Info => ffi::PK_PACKAGE_SACK_SORT_TYPE_INFO,
            Self::PackageId => ffi::PK_PACKAGE_SACK_SORT_TYPE_PACKAGE_ID,
            Self::Summary => ffi::PK_PACKAGE_SACK_SORT_TYPE_SUMMARY,
            Self::Last => ffi::PK_PACKAGE_SACK_SORT_TYPE_LAST,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::PkPackageSackSortType> for PackageSackSortType {
    #[inline]
unsafe fn from_glib(value: ffi::PkPackageSackSortType) -> Self {
        
match value {
            ffi::PK_PACKAGE_SACK_SORT_TYPE_NAME => Self::Name,
            ffi::PK_PACKAGE_SACK_SORT_TYPE_INFO => Self::Info,
            ffi::PK_PACKAGE_SACK_SORT_TYPE_PACKAGE_ID => Self::PackageId,
            ffi::PK_PACKAGE_SACK_SORT_TYPE_SUMMARY => Self::Summary,
            ffi::PK_PACKAGE_SACK_SORT_TYPE_LAST => Self::Last,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for PackageSackSortType {
                #[inline]
    #[doc(alias = "pk_package_sack_sort_type_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::pk_package_sack_sort_type_get_type()) }
                }
            }

impl glib::HasParamSpec for PackageSackSortType {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for PackageSackSortType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for PackageSackSortType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PackageSackSortType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<PackageSackSortType> for glib::Value {
    #[inline]
    fn from(v: PackageSackSortType) -> Self {
        ToValue::to_value(&v)
    }
}

/// Flag to show which progress field has been updated.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PkProgressType")]
pub enum ProgressType {
    #[doc(alias = "PK_PROGRESS_TYPE_PACKAGE_ID")]
    PackageId,
    #[doc(alias = "PK_PROGRESS_TYPE_TRANSACTION_ID")]
    TransactionId,
    #[doc(alias = "PK_PROGRESS_TYPE_PERCENTAGE")]
    Percentage,
    #[doc(alias = "PK_PROGRESS_TYPE_ALLOW_CANCEL")]
    AllowCancel,
    #[doc(alias = "PK_PROGRESS_TYPE_STATUS")]
    Status,
    #[doc(alias = "PK_PROGRESS_TYPE_ROLE")]
    Role,
    #[doc(alias = "PK_PROGRESS_TYPE_CALLER_ACTIVE")]
    CallerActive,
    #[doc(alias = "PK_PROGRESS_TYPE_ELAPSED_TIME")]
    ElapsedTime,
    #[doc(alias = "PK_PROGRESS_TYPE_REMAINING_TIME")]
    RemainingTime,
    #[doc(alias = "PK_PROGRESS_TYPE_SPEED")]
    Speed,
    #[doc(alias = "PK_PROGRESS_TYPE_DOWNLOAD_SIZE_REMAINING")]
    DownloadSizeRemaining,
    #[doc(alias = "PK_PROGRESS_TYPE_UID")]
    Uid,
    #[doc(alias = "PK_PROGRESS_TYPE_PACKAGE")]
    Package,
    #[doc(alias = "PK_PROGRESS_TYPE_ITEM_PROGRESS")]
    ItemProgress,
    #[doc(alias = "PK_PROGRESS_TYPE_TRANSACTION_FLAGS")]
    TransactionFlags,
    #[doc(alias = "PK_PROGRESS_TYPE_INVALID")]
    Invalid,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ProgressType {
    type GlibType = ffi::PkProgressType;

    fn into_glib(self) -> ffi::PkProgressType {
match self {
            Self::PackageId => ffi::PK_PROGRESS_TYPE_PACKAGE_ID,
            Self::TransactionId => ffi::PK_PROGRESS_TYPE_TRANSACTION_ID,
            Self::Percentage => ffi::PK_PROGRESS_TYPE_PERCENTAGE,
            Self::AllowCancel => ffi::PK_PROGRESS_TYPE_ALLOW_CANCEL,
            Self::Status => ffi::PK_PROGRESS_TYPE_STATUS,
            Self::Role => ffi::PK_PROGRESS_TYPE_ROLE,
            Self::CallerActive => ffi::PK_PROGRESS_TYPE_CALLER_ACTIVE,
            Self::ElapsedTime => ffi::PK_PROGRESS_TYPE_ELAPSED_TIME,
            Self::RemainingTime => ffi::PK_PROGRESS_TYPE_REMAINING_TIME,
            Self::Speed => ffi::PK_PROGRESS_TYPE_SPEED,
            Self::DownloadSizeRemaining => ffi::PK_PROGRESS_TYPE_DOWNLOAD_SIZE_REMAINING,
            Self::Uid => ffi::PK_PROGRESS_TYPE_UID,
            Self::Package => ffi::PK_PROGRESS_TYPE_PACKAGE,
            Self::ItemProgress => ffi::PK_PROGRESS_TYPE_ITEM_PROGRESS,
            Self::TransactionFlags => ffi::PK_PROGRESS_TYPE_TRANSACTION_FLAGS,
            Self::Invalid => ffi::PK_PROGRESS_TYPE_INVALID,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::PkProgressType> for ProgressType {
    unsafe fn from_glib(value: ffi::PkProgressType) -> Self {
        
match value {
            ffi::PK_PROGRESS_TYPE_PACKAGE_ID => Self::PackageId,
            ffi::PK_PROGRESS_TYPE_TRANSACTION_ID => Self::TransactionId,
            ffi::PK_PROGRESS_TYPE_PERCENTAGE => Self::Percentage,
            ffi::PK_PROGRESS_TYPE_ALLOW_CANCEL => Self::AllowCancel,
            ffi::PK_PROGRESS_TYPE_STATUS => Self::Status,
            ffi::PK_PROGRESS_TYPE_ROLE => Self::Role,
            ffi::PK_PROGRESS_TYPE_CALLER_ACTIVE => Self::CallerActive,
            ffi::PK_PROGRESS_TYPE_ELAPSED_TIME => Self::ElapsedTime,
            ffi::PK_PROGRESS_TYPE_REMAINING_TIME => Self::RemainingTime,
            ffi::PK_PROGRESS_TYPE_SPEED => Self::Speed,
            ffi::PK_PROGRESS_TYPE_DOWNLOAD_SIZE_REMAINING => Self::DownloadSizeRemaining,
            ffi::PK_PROGRESS_TYPE_UID => Self::Uid,
            ffi::PK_PROGRESS_TYPE_PACKAGE => Self::Package,
            ffi::PK_PROGRESS_TYPE_ITEM_PROGRESS => Self::ItemProgress,
            ffi::PK_PROGRESS_TYPE_TRANSACTION_FLAGS => Self::TransactionFlags,
            ffi::PK_PROGRESS_TYPE_INVALID => Self::Invalid,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for ProgressType {
                #[inline]
    #[doc(alias = "pk_progress_type_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::pk_progress_type_get_type()) }
                }
            }

impl glib::HasParamSpec for ProgressType {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for ProgressType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ProgressType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ProgressType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ProgressType> for glib::Value {
    #[inline]
    fn from(v: ProgressType) -> Self {
        ToValue::to_value(&v)
    }
}

/// What restart we need to after a transaction, ordered by severity
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PkRestartEnum")]
pub enum RestartEnum {
    #[doc(alias = "PK_RESTART_ENUM_UNKNOWN")]
    Unknown,
    #[doc(alias = "PK_RESTART_ENUM_NONE")]
    None,
    #[doc(alias = "PK_RESTART_ENUM_APPLICATION")]
    Application,
    #[doc(alias = "PK_RESTART_ENUM_SESSION")]
    Session,
    #[doc(alias = "PK_RESTART_ENUM_SYSTEM")]
    System,
    #[doc(alias = "PK_RESTART_ENUM_SECURITY_SESSION")]
    SecuritySession,
    #[doc(alias = "PK_RESTART_ENUM_SECURITY_SYSTEM")]
    SecuritySystem,
    #[doc(alias = "PK_RESTART_ENUM_LAST")]
    Last,
#[doc(hidden)]
    __Unknown(i32),
}

impl RestartEnum {
    #[cfg(feature = "v0_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
    #[doc(alias = "pk_restart_enum_from_string")]
    pub fn from_string(restart: &str) -> RestartEnum {
        unsafe {
            from_glib(ffi::pk_restart_enum_from_string(restart.to_glib_none().0))
        }
    }

    #[cfg(feature = "v0_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
    #[doc(alias = "pk_restart_enum_to_string")]
    #[doc(alias = "to_string")]
    pub fn to_str(self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::pk_restart_enum_to_string(self.into_glib()))
        }
    }
}

#[doc(hidden)]
impl IntoGlib for RestartEnum {
    type GlibType = ffi::PkRestartEnum;

    #[inline]
fn into_glib(self) -> ffi::PkRestartEnum {
match self {
            Self::Unknown => ffi::PK_RESTART_ENUM_UNKNOWN,
            Self::None => ffi::PK_RESTART_ENUM_NONE,
            Self::Application => ffi::PK_RESTART_ENUM_APPLICATION,
            Self::Session => ffi::PK_RESTART_ENUM_SESSION,
            Self::System => ffi::PK_RESTART_ENUM_SYSTEM,
            Self::SecuritySession => ffi::PK_RESTART_ENUM_SECURITY_SESSION,
            Self::SecuritySystem => ffi::PK_RESTART_ENUM_SECURITY_SYSTEM,
            Self::Last => ffi::PK_RESTART_ENUM_LAST,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::PkRestartEnum> for RestartEnum {
    #[inline]
unsafe fn from_glib(value: ffi::PkRestartEnum) -> Self {
        
match value {
            ffi::PK_RESTART_ENUM_UNKNOWN => Self::Unknown,
            ffi::PK_RESTART_ENUM_NONE => Self::None,
            ffi::PK_RESTART_ENUM_APPLICATION => Self::Application,
            ffi::PK_RESTART_ENUM_SESSION => Self::Session,
            ffi::PK_RESTART_ENUM_SYSTEM => Self::System,
            ffi::PK_RESTART_ENUM_SECURITY_SESSION => Self::SecuritySession,
            ffi::PK_RESTART_ENUM_SECURITY_SYSTEM => Self::SecuritySystem,
            ffi::PK_RESTART_ENUM_LAST => Self::Last,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for RestartEnum {
                #[inline]
    #[doc(alias = "pk_restart_enum_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::pk_restart_enum_get_type()) }
                }
            }

impl glib::HasParamSpec for RestartEnum {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for RestartEnum {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for RestartEnum {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for RestartEnum {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<RestartEnum> for glib::Value {
    #[inline]
    fn from(v: RestartEnum) -> Self {
        ToValue::to_value(&v)
    }
}

/// What we were asked to do, this never changes for the lifetime of the
/// transaction.
/// Icons that have to represent the whole "aim" of the transaction will use
/// these constants
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PkRoleEnum")]
pub enum RoleEnum {
    #[doc(alias = "PK_ROLE_ENUM_UNKNOWN")]
    Unknown,
    #[doc(alias = "PK_ROLE_ENUM_CANCEL")]
    Cancel,
    #[doc(alias = "PK_ROLE_ENUM_DEPENDS_ON")]
    DependsOn,
    #[doc(alias = "PK_ROLE_ENUM_GET_DETAILS")]
    GetDetails,
    #[doc(alias = "PK_ROLE_ENUM_GET_FILES")]
    GetFiles,
    #[doc(alias = "PK_ROLE_ENUM_GET_PACKAGES")]
    GetPackages,
    #[doc(alias = "PK_ROLE_ENUM_GET_REPO_LIST")]
    GetRepoList,
    #[doc(alias = "PK_ROLE_ENUM_REQUIRED_BY")]
    RequiredBy,
    #[doc(alias = "PK_ROLE_ENUM_GET_UPDATE_DETAIL")]
    GetUpdateDetail,
    #[doc(alias = "PK_ROLE_ENUM_GET_UPDATES")]
    GetUpdates,
    #[doc(alias = "PK_ROLE_ENUM_INSTALL_FILES")]
    InstallFiles,
    #[doc(alias = "PK_ROLE_ENUM_INSTALL_PACKAGES")]
    InstallPackages,
    #[doc(alias = "PK_ROLE_ENUM_INSTALL_SIGNATURE")]
    InstallSignature,
    #[doc(alias = "PK_ROLE_ENUM_REFRESH_CACHE")]
    RefreshCache,
    #[doc(alias = "PK_ROLE_ENUM_REMOVE_PACKAGES")]
    RemovePackages,
    #[doc(alias = "PK_ROLE_ENUM_REPO_ENABLE")]
    RepoEnable,
    #[doc(alias = "PK_ROLE_ENUM_REPO_SET_DATA")]
    RepoSetData,
    #[doc(alias = "PK_ROLE_ENUM_RESOLVE")]
    Resolve,
    #[doc(alias = "PK_ROLE_ENUM_SEARCH_DETAILS")]
    SearchDetails,
    #[doc(alias = "PK_ROLE_ENUM_SEARCH_FILE")]
    SearchFile,
    #[doc(alias = "PK_ROLE_ENUM_SEARCH_GROUP")]
    SearchGroup,
    #[doc(alias = "PK_ROLE_ENUM_SEARCH_NAME")]
    SearchName,
    #[doc(alias = "PK_ROLE_ENUM_UPDATE_PACKAGES")]
    UpdatePackages,
    #[doc(alias = "PK_ROLE_ENUM_WHAT_PROVIDES")]
    WhatProvides,
    #[doc(alias = "PK_ROLE_ENUM_ACCEPT_EULA")]
    AcceptEula,
    #[doc(alias = "PK_ROLE_ENUM_DOWNLOAD_PACKAGES")]
    DownloadPackages,
    #[doc(alias = "PK_ROLE_ENUM_GET_DISTRO_UPGRADES")]
    GetDistroUpgrades,
    #[doc(alias = "PK_ROLE_ENUM_GET_CATEGORIES")]
    GetCategories,
    #[doc(alias = "PK_ROLE_ENUM_GET_OLD_TRANSACTIONS")]
    GetOldTransactions,
    #[doc(alias = "PK_ROLE_ENUM_REPAIR_SYSTEM")]
    RepairSystem,
    #[doc(alias = "PK_ROLE_ENUM_GET_DETAILS_LOCAL")]
    GetDetailsLocal,
    #[doc(alias = "PK_ROLE_ENUM_GET_FILES_LOCAL")]
    GetFilesLocal,
    #[doc(alias = "PK_ROLE_ENUM_REPO_REMOVE")]
    RepoRemove,
    #[doc(alias = "PK_ROLE_ENUM_UPGRADE_SYSTEM")]
    UpgradeSystem,
    #[doc(alias = "PK_ROLE_ENUM_LAST")]
    Last,
#[doc(hidden)]
    __Unknown(i32),
}

impl RoleEnum {
    #[cfg(feature = "v0_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
    #[doc(alias = "pk_role_enum_from_string")]
    pub fn from_string(role: &str) -> RoleEnum {
        unsafe {
            from_glib(ffi::pk_role_enum_from_string(role.to_glib_none().0))
        }
    }

    #[cfg(feature = "v0_7_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_7_2")))]
    #[doc(alias = "pk_role_enum_to_localised_present")]
    pub fn to_localised_present(self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::pk_role_enum_to_localised_present(self.into_glib()))
        }
    }

    #[cfg(feature = "v0_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
    #[doc(alias = "pk_role_enum_to_string")]
    #[doc(alias = "to_string")]
    pub fn to_str(self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::pk_role_enum_to_string(self.into_glib()))
        }
    }
}

#[doc(hidden)]
impl IntoGlib for RoleEnum {
    type GlibType = ffi::PkRoleEnum;

    fn into_glib(self) -> ffi::PkRoleEnum {
match self {
            Self::Unknown => ffi::PK_ROLE_ENUM_UNKNOWN,
            Self::Cancel => ffi::PK_ROLE_ENUM_CANCEL,
            Self::DependsOn => ffi::PK_ROLE_ENUM_DEPENDS_ON,
            Self::GetDetails => ffi::PK_ROLE_ENUM_GET_DETAILS,
            Self::GetFiles => ffi::PK_ROLE_ENUM_GET_FILES,
            Self::GetPackages => ffi::PK_ROLE_ENUM_GET_PACKAGES,
            Self::GetRepoList => ffi::PK_ROLE_ENUM_GET_REPO_LIST,
            Self::RequiredBy => ffi::PK_ROLE_ENUM_REQUIRED_BY,
            Self::GetUpdateDetail => ffi::PK_ROLE_ENUM_GET_UPDATE_DETAIL,
            Self::GetUpdates => ffi::PK_ROLE_ENUM_GET_UPDATES,
            Self::InstallFiles => ffi::PK_ROLE_ENUM_INSTALL_FILES,
            Self::InstallPackages => ffi::PK_ROLE_ENUM_INSTALL_PACKAGES,
            Self::InstallSignature => ffi::PK_ROLE_ENUM_INSTALL_SIGNATURE,
            Self::RefreshCache => ffi::PK_ROLE_ENUM_REFRESH_CACHE,
            Self::RemovePackages => ffi::PK_ROLE_ENUM_REMOVE_PACKAGES,
            Self::RepoEnable => ffi::PK_ROLE_ENUM_REPO_ENABLE,
            Self::RepoSetData => ffi::PK_ROLE_ENUM_REPO_SET_DATA,
            Self::Resolve => ffi::PK_ROLE_ENUM_RESOLVE,
            Self::SearchDetails => ffi::PK_ROLE_ENUM_SEARCH_DETAILS,
            Self::SearchFile => ffi::PK_ROLE_ENUM_SEARCH_FILE,
            Self::SearchGroup => ffi::PK_ROLE_ENUM_SEARCH_GROUP,
            Self::SearchName => ffi::PK_ROLE_ENUM_SEARCH_NAME,
            Self::UpdatePackages => ffi::PK_ROLE_ENUM_UPDATE_PACKAGES,
            Self::WhatProvides => ffi::PK_ROLE_ENUM_WHAT_PROVIDES,
            Self::AcceptEula => ffi::PK_ROLE_ENUM_ACCEPT_EULA,
            Self::DownloadPackages => ffi::PK_ROLE_ENUM_DOWNLOAD_PACKAGES,
            Self::GetDistroUpgrades => ffi::PK_ROLE_ENUM_GET_DISTRO_UPGRADES,
            Self::GetCategories => ffi::PK_ROLE_ENUM_GET_CATEGORIES,
            Self::GetOldTransactions => ffi::PK_ROLE_ENUM_GET_OLD_TRANSACTIONS,
            Self::RepairSystem => ffi::PK_ROLE_ENUM_REPAIR_SYSTEM,
            Self::GetDetailsLocal => ffi::PK_ROLE_ENUM_GET_DETAILS_LOCAL,
            Self::GetFilesLocal => ffi::PK_ROLE_ENUM_GET_FILES_LOCAL,
            Self::RepoRemove => ffi::PK_ROLE_ENUM_REPO_REMOVE,
            Self::UpgradeSystem => ffi::PK_ROLE_ENUM_UPGRADE_SYSTEM,
            Self::Last => ffi::PK_ROLE_ENUM_LAST,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::PkRoleEnum> for RoleEnum {
    unsafe fn from_glib(value: ffi::PkRoleEnum) -> Self {
        
match value {
            ffi::PK_ROLE_ENUM_UNKNOWN => Self::Unknown,
            ffi::PK_ROLE_ENUM_CANCEL => Self::Cancel,
            ffi::PK_ROLE_ENUM_DEPENDS_ON => Self::DependsOn,
            ffi::PK_ROLE_ENUM_GET_DETAILS => Self::GetDetails,
            ffi::PK_ROLE_ENUM_GET_FILES => Self::GetFiles,
            ffi::PK_ROLE_ENUM_GET_PACKAGES => Self::GetPackages,
            ffi::PK_ROLE_ENUM_GET_REPO_LIST => Self::GetRepoList,
            ffi::PK_ROLE_ENUM_REQUIRED_BY => Self::RequiredBy,
            ffi::PK_ROLE_ENUM_GET_UPDATE_DETAIL => Self::GetUpdateDetail,
            ffi::PK_ROLE_ENUM_GET_UPDATES => Self::GetUpdates,
            ffi::PK_ROLE_ENUM_INSTALL_FILES => Self::InstallFiles,
            ffi::PK_ROLE_ENUM_INSTALL_PACKAGES => Self::InstallPackages,
            ffi::PK_ROLE_ENUM_INSTALL_SIGNATURE => Self::InstallSignature,
            ffi::PK_ROLE_ENUM_REFRESH_CACHE => Self::RefreshCache,
            ffi::PK_ROLE_ENUM_REMOVE_PACKAGES => Self::RemovePackages,
            ffi::PK_ROLE_ENUM_REPO_ENABLE => Self::RepoEnable,
            ffi::PK_ROLE_ENUM_REPO_SET_DATA => Self::RepoSetData,
            ffi::PK_ROLE_ENUM_RESOLVE => Self::Resolve,
            ffi::PK_ROLE_ENUM_SEARCH_DETAILS => Self::SearchDetails,
            ffi::PK_ROLE_ENUM_SEARCH_FILE => Self::SearchFile,
            ffi::PK_ROLE_ENUM_SEARCH_GROUP => Self::SearchGroup,
            ffi::PK_ROLE_ENUM_SEARCH_NAME => Self::SearchName,
            ffi::PK_ROLE_ENUM_UPDATE_PACKAGES => Self::UpdatePackages,
            ffi::PK_ROLE_ENUM_WHAT_PROVIDES => Self::WhatProvides,
            ffi::PK_ROLE_ENUM_ACCEPT_EULA => Self::AcceptEula,
            ffi::PK_ROLE_ENUM_DOWNLOAD_PACKAGES => Self::DownloadPackages,
            ffi::PK_ROLE_ENUM_GET_DISTRO_UPGRADES => Self::GetDistroUpgrades,
            ffi::PK_ROLE_ENUM_GET_CATEGORIES => Self::GetCategories,
            ffi::PK_ROLE_ENUM_GET_OLD_TRANSACTIONS => Self::GetOldTransactions,
            ffi::PK_ROLE_ENUM_REPAIR_SYSTEM => Self::RepairSystem,
            ffi::PK_ROLE_ENUM_GET_DETAILS_LOCAL => Self::GetDetailsLocal,
            ffi::PK_ROLE_ENUM_GET_FILES_LOCAL => Self::GetFilesLocal,
            ffi::PK_ROLE_ENUM_REPO_REMOVE => Self::RepoRemove,
            ffi::PK_ROLE_ENUM_UPGRADE_SYSTEM => Self::UpgradeSystem,
            ffi::PK_ROLE_ENUM_LAST => Self::Last,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for RoleEnum {
                #[inline]
    #[doc(alias = "pk_role_enum_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::pk_role_enum_get_type()) }
                }
            }

impl glib::HasParamSpec for RoleEnum {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for RoleEnum {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for RoleEnum {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for RoleEnum {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<RoleEnum> for glib::Value {
    #[inline]
    fn from(v: RoleEnum) -> Self {
        ToValue::to_value(&v)
    }
}

/// The signature type type
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PkSigTypeEnum")]
pub enum SigTypeEnum {
    #[doc(alias = "PK_SIGTYPE_ENUM_UNKNOWN")]
    Unknown,
    #[doc(alias = "PK_SIGTYPE_ENUM_GPG")]
    Gpg,
    #[doc(alias = "PK_SIGTYPE_ENUM_LAST")]
    Last,
#[doc(hidden)]
    __Unknown(i32),
}

impl SigTypeEnum {
    #[doc(alias = "pk_sig_type_enum_from_string")]
    pub fn from_string(sig_type: &str) -> SigTypeEnum {
        unsafe {
            from_glib(ffi::pk_sig_type_enum_from_string(sig_type.to_glib_none().0))
        }
    }

    #[cfg(feature = "v0_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
    #[doc(alias = "pk_sig_type_enum_to_string")]
    #[doc(alias = "to_string")]
    pub fn to_str(self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::pk_sig_type_enum_to_string(self.into_glib()))
        }
    }
}

#[doc(hidden)]
impl IntoGlib for SigTypeEnum {
    type GlibType = ffi::PkSigTypeEnum;

    #[inline]
fn into_glib(self) -> ffi::PkSigTypeEnum {
match self {
            Self::Unknown => ffi::PK_SIGTYPE_ENUM_UNKNOWN,
            Self::Gpg => ffi::PK_SIGTYPE_ENUM_GPG,
            Self::Last => ffi::PK_SIGTYPE_ENUM_LAST,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::PkSigTypeEnum> for SigTypeEnum {
    #[inline]
unsafe fn from_glib(value: ffi::PkSigTypeEnum) -> Self {
        
match value {
            ffi::PK_SIGTYPE_ENUM_UNKNOWN => Self::Unknown,
            ffi::PK_SIGTYPE_ENUM_GPG => Self::Gpg,
            ffi::PK_SIGTYPE_ENUM_LAST => Self::Last,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for SigTypeEnum {
                #[inline]
    #[doc(alias = "pk_sig_type_enum_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::pk_sig_type_enum_get_type()) }
                }
            }

impl glib::HasParamSpec for SigTypeEnum {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for SigTypeEnum {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SigTypeEnum {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SigTypeEnum {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SigTypeEnum> for glib::Value {
    #[inline]
    fn from(v: SigTypeEnum) -> Self {
        ToValue::to_value(&v)
    }
}

/// What status we are now; this can change for each transaction giving a
/// status of what sort of thing is happening
/// Icons that change to represent the current status of the transaction will
/// use these constants
/// If you add to these, make sure you add filenames in gpk-watch.c also
///
/// A typical transaction will do:
/// - schedule task
/// WAIT
/// - run task
/// SETUP
/// - wait for lock
/// RUNNING
///
/// This means that backends should run pk_backend_set_status (backend, PK_STATUS_ENUM_RUNNING)
/// when they are ready to start running the transaction and after a lock has been got.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PkStatusEnum")]
pub enum StatusEnum {
    #[doc(alias = "PK_STATUS_ENUM_UNKNOWN")]
    Unknown,
    #[doc(alias = "PK_STATUS_ENUM_WAIT")]
    Wait,
    #[doc(alias = "PK_STATUS_ENUM_SETUP")]
    Setup,
    #[doc(alias = "PK_STATUS_ENUM_RUNNING")]
    Running,
    #[doc(alias = "PK_STATUS_ENUM_QUERY")]
    Query,
    #[doc(alias = "PK_STATUS_ENUM_INFO")]
    Info,
    #[doc(alias = "PK_STATUS_ENUM_REMOVE")]
    Remove,
    #[doc(alias = "PK_STATUS_ENUM_REFRESH_CACHE")]
    RefreshCache,
    #[doc(alias = "PK_STATUS_ENUM_DOWNLOAD")]
    Download,
    #[doc(alias = "PK_STATUS_ENUM_INSTALL")]
    Install,
    #[doc(alias = "PK_STATUS_ENUM_UPDATE")]
    Update,
    #[doc(alias = "PK_STATUS_ENUM_CLEANUP")]
    Cleanup,
    #[doc(alias = "PK_STATUS_ENUM_OBSOLETE")]
    Obsolete,
    #[doc(alias = "PK_STATUS_ENUM_DEP_RESOLVE")]
    DepResolve,
    #[doc(alias = "PK_STATUS_ENUM_SIG_CHECK")]
    SigCheck,
    #[doc(alias = "PK_STATUS_ENUM_TEST_COMMIT")]
    TestCommit,
    #[doc(alias = "PK_STATUS_ENUM_COMMIT")]
    Commit,
    #[doc(alias = "PK_STATUS_ENUM_REQUEST")]
    Request,
    #[doc(alias = "PK_STATUS_ENUM_FINISHED")]
    Finished,
    #[doc(alias = "PK_STATUS_ENUM_CANCEL")]
    Cancel,
    #[doc(alias = "PK_STATUS_ENUM_DOWNLOAD_REPOSITORY")]
    DownloadRepository,
    #[doc(alias = "PK_STATUS_ENUM_DOWNLOAD_PACKAGELIST")]
    DownloadPackagelist,
    #[doc(alias = "PK_STATUS_ENUM_DOWNLOAD_FILELIST")]
    DownloadFilelist,
    #[doc(alias = "PK_STATUS_ENUM_DOWNLOAD_CHANGELOG")]
    DownloadChangelog,
    #[doc(alias = "PK_STATUS_ENUM_DOWNLOAD_GROUP")]
    DownloadGroup,
    #[doc(alias = "PK_STATUS_ENUM_DOWNLOAD_UPDATEINFO")]
    DownloadUpdateinfo,
    #[doc(alias = "PK_STATUS_ENUM_REPACKAGING")]
    Repackaging,
    #[doc(alias = "PK_STATUS_ENUM_LOADING_CACHE")]
    LoadingCache,
    #[doc(alias = "PK_STATUS_ENUM_SCAN_APPLICATIONS")]
    ScanApplications,
    #[doc(alias = "PK_STATUS_ENUM_GENERATE_PACKAGE_LIST")]
    GeneratePackageList,
    #[doc(alias = "PK_STATUS_ENUM_WAITING_FOR_LOCK")]
    WaitingForLock,
    #[doc(alias = "PK_STATUS_ENUM_WAITING_FOR_AUTH")]
    WaitingForAuth,
    #[doc(alias = "PK_STATUS_ENUM_SCAN_PROCESS_LIST")]
    ScanProcessList,
    #[doc(alias = "PK_STATUS_ENUM_CHECK_EXECUTABLE_FILES")]
    CheckExecutableFiles,
    #[doc(alias = "PK_STATUS_ENUM_CHECK_LIBRARIES")]
    CheckLibraries,
    #[doc(alias = "PK_STATUS_ENUM_COPY_FILES")]
    CopyFiles,
    #[doc(alias = "PK_STATUS_ENUM_RUN_HOOK")]
    RunHook,
    #[doc(alias = "PK_STATUS_ENUM_LAST")]
    Last,
#[doc(hidden)]
    __Unknown(i32),
}

impl StatusEnum {
    #[cfg(feature = "v0_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
    #[doc(alias = "pk_status_enum_from_string")]
    pub fn from_string(status: &str) -> StatusEnum {
        unsafe {
            from_glib(ffi::pk_status_enum_from_string(status.to_glib_none().0))
        }
    }

    #[doc(alias = "pk_status_enum_to_localised_text")]
    pub fn to_localised_text(self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::pk_status_enum_to_localised_text(self.into_glib()))
        }
    }

    #[cfg(feature = "v0_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
    #[doc(alias = "pk_status_enum_to_string")]
    #[doc(alias = "to_string")]
    pub fn to_str(self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::pk_status_enum_to_string(self.into_glib()))
        }
    }
}

#[doc(hidden)]
impl IntoGlib for StatusEnum {
    type GlibType = ffi::PkStatusEnum;

    fn into_glib(self) -> ffi::PkStatusEnum {
match self {
            Self::Unknown => ffi::PK_STATUS_ENUM_UNKNOWN,
            Self::Wait => ffi::PK_STATUS_ENUM_WAIT,
            Self::Setup => ffi::PK_STATUS_ENUM_SETUP,
            Self::Running => ffi::PK_STATUS_ENUM_RUNNING,
            Self::Query => ffi::PK_STATUS_ENUM_QUERY,
            Self::Info => ffi::PK_STATUS_ENUM_INFO,
            Self::Remove => ffi::PK_STATUS_ENUM_REMOVE,
            Self::RefreshCache => ffi::PK_STATUS_ENUM_REFRESH_CACHE,
            Self::Download => ffi::PK_STATUS_ENUM_DOWNLOAD,
            Self::Install => ffi::PK_STATUS_ENUM_INSTALL,
            Self::Update => ffi::PK_STATUS_ENUM_UPDATE,
            Self::Cleanup => ffi::PK_STATUS_ENUM_CLEANUP,
            Self::Obsolete => ffi::PK_STATUS_ENUM_OBSOLETE,
            Self::DepResolve => ffi::PK_STATUS_ENUM_DEP_RESOLVE,
            Self::SigCheck => ffi::PK_STATUS_ENUM_SIG_CHECK,
            Self::TestCommit => ffi::PK_STATUS_ENUM_TEST_COMMIT,
            Self::Commit => ffi::PK_STATUS_ENUM_COMMIT,
            Self::Request => ffi::PK_STATUS_ENUM_REQUEST,
            Self::Finished => ffi::PK_STATUS_ENUM_FINISHED,
            Self::Cancel => ffi::PK_STATUS_ENUM_CANCEL,
            Self::DownloadRepository => ffi::PK_STATUS_ENUM_DOWNLOAD_REPOSITORY,
            Self::DownloadPackagelist => ffi::PK_STATUS_ENUM_DOWNLOAD_PACKAGELIST,
            Self::DownloadFilelist => ffi::PK_STATUS_ENUM_DOWNLOAD_FILELIST,
            Self::DownloadChangelog => ffi::PK_STATUS_ENUM_DOWNLOAD_CHANGELOG,
            Self::DownloadGroup => ffi::PK_STATUS_ENUM_DOWNLOAD_GROUP,
            Self::DownloadUpdateinfo => ffi::PK_STATUS_ENUM_DOWNLOAD_UPDATEINFO,
            Self::Repackaging => ffi::PK_STATUS_ENUM_REPACKAGING,
            Self::LoadingCache => ffi::PK_STATUS_ENUM_LOADING_CACHE,
            Self::ScanApplications => ffi::PK_STATUS_ENUM_SCAN_APPLICATIONS,
            Self::GeneratePackageList => ffi::PK_STATUS_ENUM_GENERATE_PACKAGE_LIST,
            Self::WaitingForLock => ffi::PK_STATUS_ENUM_WAITING_FOR_LOCK,
            Self::WaitingForAuth => ffi::PK_STATUS_ENUM_WAITING_FOR_AUTH,
            Self::ScanProcessList => ffi::PK_STATUS_ENUM_SCAN_PROCESS_LIST,
            Self::CheckExecutableFiles => ffi::PK_STATUS_ENUM_CHECK_EXECUTABLE_FILES,
            Self::CheckLibraries => ffi::PK_STATUS_ENUM_CHECK_LIBRARIES,
            Self::CopyFiles => ffi::PK_STATUS_ENUM_COPY_FILES,
            Self::RunHook => ffi::PK_STATUS_ENUM_RUN_HOOK,
            Self::Last => ffi::PK_STATUS_ENUM_LAST,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::PkStatusEnum> for StatusEnum {
    unsafe fn from_glib(value: ffi::PkStatusEnum) -> Self {
        
match value {
            ffi::PK_STATUS_ENUM_UNKNOWN => Self::Unknown,
            ffi::PK_STATUS_ENUM_WAIT => Self::Wait,
            ffi::PK_STATUS_ENUM_SETUP => Self::Setup,
            ffi::PK_STATUS_ENUM_RUNNING => Self::Running,
            ffi::PK_STATUS_ENUM_QUERY => Self::Query,
            ffi::PK_STATUS_ENUM_INFO => Self::Info,
            ffi::PK_STATUS_ENUM_REMOVE => Self::Remove,
            ffi::PK_STATUS_ENUM_REFRESH_CACHE => Self::RefreshCache,
            ffi::PK_STATUS_ENUM_DOWNLOAD => Self::Download,
            ffi::PK_STATUS_ENUM_INSTALL => Self::Install,
            ffi::PK_STATUS_ENUM_UPDATE => Self::Update,
            ffi::PK_STATUS_ENUM_CLEANUP => Self::Cleanup,
            ffi::PK_STATUS_ENUM_OBSOLETE => Self::Obsolete,
            ffi::PK_STATUS_ENUM_DEP_RESOLVE => Self::DepResolve,
            ffi::PK_STATUS_ENUM_SIG_CHECK => Self::SigCheck,
            ffi::PK_STATUS_ENUM_TEST_COMMIT => Self::TestCommit,
            ffi::PK_STATUS_ENUM_COMMIT => Self::Commit,
            ffi::PK_STATUS_ENUM_REQUEST => Self::Request,
            ffi::PK_STATUS_ENUM_FINISHED => Self::Finished,
            ffi::PK_STATUS_ENUM_CANCEL => Self::Cancel,
            ffi::PK_STATUS_ENUM_DOWNLOAD_REPOSITORY => Self::DownloadRepository,
            ffi::PK_STATUS_ENUM_DOWNLOAD_PACKAGELIST => Self::DownloadPackagelist,
            ffi::PK_STATUS_ENUM_DOWNLOAD_FILELIST => Self::DownloadFilelist,
            ffi::PK_STATUS_ENUM_DOWNLOAD_CHANGELOG => Self::DownloadChangelog,
            ffi::PK_STATUS_ENUM_DOWNLOAD_GROUP => Self::DownloadGroup,
            ffi::PK_STATUS_ENUM_DOWNLOAD_UPDATEINFO => Self::DownloadUpdateinfo,
            ffi::PK_STATUS_ENUM_REPACKAGING => Self::Repackaging,
            ffi::PK_STATUS_ENUM_LOADING_CACHE => Self::LoadingCache,
            ffi::PK_STATUS_ENUM_SCAN_APPLICATIONS => Self::ScanApplications,
            ffi::PK_STATUS_ENUM_GENERATE_PACKAGE_LIST => Self::GeneratePackageList,
            ffi::PK_STATUS_ENUM_WAITING_FOR_LOCK => Self::WaitingForLock,
            ffi::PK_STATUS_ENUM_WAITING_FOR_AUTH => Self::WaitingForAuth,
            ffi::PK_STATUS_ENUM_SCAN_PROCESS_LIST => Self::ScanProcessList,
            ffi::PK_STATUS_ENUM_CHECK_EXECUTABLE_FILES => Self::CheckExecutableFiles,
            ffi::PK_STATUS_ENUM_CHECK_LIBRARIES => Self::CheckLibraries,
            ffi::PK_STATUS_ENUM_COPY_FILES => Self::CopyFiles,
            ffi::PK_STATUS_ENUM_RUN_HOOK => Self::RunHook,
            ffi::PK_STATUS_ENUM_LAST => Self::Last,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for StatusEnum {
                #[inline]
    #[doc(alias = "pk_status_enum_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::pk_status_enum_get_type()) }
                }
            }

impl glib::HasParamSpec for StatusEnum {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for StatusEnum {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for StatusEnum {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for StatusEnum {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<StatusEnum> for glib::Value {
    #[inline]
    fn from(v: StatusEnum) -> Self {
        ToValue::to_value(&v)
    }
}

/// The transaction flags that alter how the transaction is handled
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PkTransactionFlagEnum")]
pub enum TransactionFlagEnum {
    #[doc(alias = "PK_TRANSACTION_FLAG_ENUM_NONE")]
    None,
    #[doc(alias = "PK_TRANSACTION_FLAG_ENUM_ONLY_TRUSTED")]
    OnlyTrusted,
    #[doc(alias = "PK_TRANSACTION_FLAG_ENUM_SIMULATE")]
    Simulate,
    #[doc(alias = "PK_TRANSACTION_FLAG_ENUM_ONLY_DOWNLOAD")]
    OnlyDownload,
    #[doc(alias = "PK_TRANSACTION_FLAG_ENUM_ALLOW_REINSTALL")]
    AllowReinstall,
    #[doc(alias = "PK_TRANSACTION_FLAG_ENUM_JUST_REINSTALL")]
    JustReinstall,
    #[doc(alias = "PK_TRANSACTION_FLAG_ENUM_ALLOW_DOWNGRADE")]
    AllowDowngrade,
    #[doc(alias = "PK_TRANSACTION_FLAG_ENUM_LAST")]
    Last,
#[doc(hidden)]
    __Unknown(i32),
}

impl TransactionFlagEnum {
    #[cfg(feature = "v0_8_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_8_1")))]
    #[doc(alias = "pk_transaction_flag_enum_from_string")]
    pub fn from_string(transaction_flag: &str) -> TransactionFlagEnum {
        unsafe {
            from_glib(ffi::pk_transaction_flag_enum_from_string(transaction_flag.to_glib_none().0))
        }
    }

    #[cfg(feature = "v0_8_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_8_1")))]
    #[doc(alias = "pk_transaction_flag_enum_to_string")]
    #[doc(alias = "to_string")]
    pub fn to_str(self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::pk_transaction_flag_enum_to_string(self.into_glib()))
        }
    }
}

#[doc(hidden)]
impl IntoGlib for TransactionFlagEnum {
    type GlibType = ffi::PkTransactionFlagEnum;

    #[inline]
fn into_glib(self) -> ffi::PkTransactionFlagEnum {
match self {
            Self::None => ffi::PK_TRANSACTION_FLAG_ENUM_NONE,
            Self::OnlyTrusted => ffi::PK_TRANSACTION_FLAG_ENUM_ONLY_TRUSTED,
            Self::Simulate => ffi::PK_TRANSACTION_FLAG_ENUM_SIMULATE,
            Self::OnlyDownload => ffi::PK_TRANSACTION_FLAG_ENUM_ONLY_DOWNLOAD,
            Self::AllowReinstall => ffi::PK_TRANSACTION_FLAG_ENUM_ALLOW_REINSTALL,
            Self::JustReinstall => ffi::PK_TRANSACTION_FLAG_ENUM_JUST_REINSTALL,
            Self::AllowDowngrade => ffi::PK_TRANSACTION_FLAG_ENUM_ALLOW_DOWNGRADE,
            Self::Last => ffi::PK_TRANSACTION_FLAG_ENUM_LAST,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::PkTransactionFlagEnum> for TransactionFlagEnum {
    #[inline]
unsafe fn from_glib(value: ffi::PkTransactionFlagEnum) -> Self {
        
match value {
            ffi::PK_TRANSACTION_FLAG_ENUM_NONE => Self::None,
            ffi::PK_TRANSACTION_FLAG_ENUM_ONLY_TRUSTED => Self::OnlyTrusted,
            ffi::PK_TRANSACTION_FLAG_ENUM_SIMULATE => Self::Simulate,
            ffi::PK_TRANSACTION_FLAG_ENUM_ONLY_DOWNLOAD => Self::OnlyDownload,
            ffi::PK_TRANSACTION_FLAG_ENUM_ALLOW_REINSTALL => Self::AllowReinstall,
            ffi::PK_TRANSACTION_FLAG_ENUM_JUST_REINSTALL => Self::JustReinstall,
            ffi::PK_TRANSACTION_FLAG_ENUM_ALLOW_DOWNGRADE => Self::AllowDowngrade,
            ffi::PK_TRANSACTION_FLAG_ENUM_LAST => Self::Last,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for TransactionFlagEnum {
                #[inline]
    #[doc(alias = "pk_transaction_flag_enum_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::pk_transaction_flag_enum_get_type()) }
                }
            }

impl glib::HasParamSpec for TransactionFlagEnum {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for TransactionFlagEnum {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for TransactionFlagEnum {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for TransactionFlagEnum {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<TransactionFlagEnum> for glib::Value {
    #[inline]
    fn from(v: TransactionFlagEnum) -> Self {
        ToValue::to_value(&v)
    }
}

/// What state the update is in
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PkUpdateStateEnum")]
pub enum UpdateStateEnum {
    #[doc(alias = "PK_UPDATE_STATE_ENUM_UNKNOWN")]
    Unknown,
    #[doc(alias = "PK_UPDATE_STATE_ENUM_STABLE")]
    Stable,
    #[doc(alias = "PK_UPDATE_STATE_ENUM_UNSTABLE")]
    Unstable,
    #[doc(alias = "PK_UPDATE_STATE_ENUM_TESTING")]
    Testing,
    #[doc(alias = "PK_UPDATE_STATE_ENUM_LAST")]
    Last,
#[doc(hidden)]
    __Unknown(i32),
}

impl UpdateStateEnum {
    #[cfg(feature = "v0_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
    #[doc(alias = "pk_update_state_enum_from_string")]
    pub fn from_string(update_state: &str) -> UpdateStateEnum {
        unsafe {
            from_glib(ffi::pk_update_state_enum_from_string(update_state.to_glib_none().0))
        }
    }

    #[cfg(feature = "v0_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
    #[doc(alias = "pk_update_state_enum_to_string")]
    #[doc(alias = "to_string")]
    pub fn to_str(self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::pk_update_state_enum_to_string(self.into_glib()))
        }
    }
}

#[doc(hidden)]
impl IntoGlib for UpdateStateEnum {
    type GlibType = ffi::PkUpdateStateEnum;

    #[inline]
fn into_glib(self) -> ffi::PkUpdateStateEnum {
match self {
            Self::Unknown => ffi::PK_UPDATE_STATE_ENUM_UNKNOWN,
            Self::Stable => ffi::PK_UPDATE_STATE_ENUM_STABLE,
            Self::Unstable => ffi::PK_UPDATE_STATE_ENUM_UNSTABLE,
            Self::Testing => ffi::PK_UPDATE_STATE_ENUM_TESTING,
            Self::Last => ffi::PK_UPDATE_STATE_ENUM_LAST,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::PkUpdateStateEnum> for UpdateStateEnum {
    #[inline]
unsafe fn from_glib(value: ffi::PkUpdateStateEnum) -> Self {
        
match value {
            ffi::PK_UPDATE_STATE_ENUM_UNKNOWN => Self::Unknown,
            ffi::PK_UPDATE_STATE_ENUM_STABLE => Self::Stable,
            ffi::PK_UPDATE_STATE_ENUM_UNSTABLE => Self::Unstable,
            ffi::PK_UPDATE_STATE_ENUM_TESTING => Self::Testing,
            ffi::PK_UPDATE_STATE_ENUM_LAST => Self::Last,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for UpdateStateEnum {
                #[inline]
    #[doc(alias = "pk_update_state_enum_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::pk_update_state_enum_get_type()) }
                }
            }

impl glib::HasParamSpec for UpdateStateEnum {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for UpdateStateEnum {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for UpdateStateEnum {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for UpdateStateEnum {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<UpdateStateEnum> for glib::Value {
    #[inline]
    fn from(v: UpdateStateEnum) -> Self {
        ToValue::to_value(&v)
    }
}

/// The type of distribution upgrade to perform
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "PkUpgradeKindEnum")]
pub enum UpgradeKindEnum {
    #[doc(alias = "PK_UPGRADE_KIND_ENUM_UNKNOWN")]
    Unknown,
    #[doc(alias = "PK_UPGRADE_KIND_ENUM_MINIMAL")]
    Minimal,
    #[doc(alias = "PK_UPGRADE_KIND_ENUM_DEFAULT")]
    Default,
    #[doc(alias = "PK_UPGRADE_KIND_ENUM_COMPLETE")]
    Complete,
    #[doc(alias = "PK_UPGRADE_KIND_ENUM_LAST")]
    Last,
#[doc(hidden)]
    __Unknown(i32),
}

impl UpgradeKindEnum {
    #[cfg(feature = "v0_6_11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_6_11")))]
    #[doc(alias = "pk_upgrade_kind_enum_from_string")]
    pub fn from_string(upgrade_kind: &str) -> UpgradeKindEnum {
        unsafe {
            from_glib(ffi::pk_upgrade_kind_enum_from_string(upgrade_kind.to_glib_none().0))
        }
    }

    #[cfg(feature = "v0_6_11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_6_11")))]
    #[doc(alias = "pk_upgrade_kind_enum_to_string")]
    #[doc(alias = "to_string")]
    pub fn to_str(self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::pk_upgrade_kind_enum_to_string(self.into_glib()))
        }
    }
}

#[doc(hidden)]
impl IntoGlib for UpgradeKindEnum {
    type GlibType = ffi::PkUpgradeKindEnum;

    #[inline]
fn into_glib(self) -> ffi::PkUpgradeKindEnum {
match self {
            Self::Unknown => ffi::PK_UPGRADE_KIND_ENUM_UNKNOWN,
            Self::Minimal => ffi::PK_UPGRADE_KIND_ENUM_MINIMAL,
            Self::Default => ffi::PK_UPGRADE_KIND_ENUM_DEFAULT,
            Self::Complete => ffi::PK_UPGRADE_KIND_ENUM_COMPLETE,
            Self::Last => ffi::PK_UPGRADE_KIND_ENUM_LAST,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::PkUpgradeKindEnum> for UpgradeKindEnum {
    #[inline]
unsafe fn from_glib(value: ffi::PkUpgradeKindEnum) -> Self {
        
match value {
            ffi::PK_UPGRADE_KIND_ENUM_UNKNOWN => Self::Unknown,
            ffi::PK_UPGRADE_KIND_ENUM_MINIMAL => Self::Minimal,
            ffi::PK_UPGRADE_KIND_ENUM_DEFAULT => Self::Default,
            ffi::PK_UPGRADE_KIND_ENUM_COMPLETE => Self::Complete,
            ffi::PK_UPGRADE_KIND_ENUM_LAST => Self::Last,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for UpgradeKindEnum {
                #[inline]
    #[doc(alias = "pk_upgrade_kind_enum_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::pk_upgrade_kind_enum_get_type()) }
                }
            }

impl glib::HasParamSpec for UpgradeKindEnum {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for UpgradeKindEnum {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for UpgradeKindEnum {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for UpgradeKindEnum {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<UpgradeKindEnum> for glib::Value {
    #[inline]
    fn from(v: UpgradeKindEnum) -> Self {
        ToValue::to_value(&v)
    }
}

