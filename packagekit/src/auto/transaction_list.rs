// Generated by gir (https://github.com/gtk-rs/gir @ 1c7a6b57a5fc)
// from gir-files (https://github.com/gtk-rs/gir-files.git @ 21b29d0e0c1a)
// from packagekit-gir-files
// DO NOT EDIT

use glib::{prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_};

glib::wrapper! {
    #[doc(alias = "PkTransactionList")]
    pub struct TransactionList(Object<ffi::PkTransactionList, ffi::PkTransactionListClass>);

    match fn {
        type_ => || ffi::pk_transaction_list_get_type(),
    }
}

impl TransactionList {
        pub const NONE: Option<&'static TransactionList> = None;
    

    #[cfg(feature = "v0_5_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
    #[doc(alias = "pk_transaction_list_new")]
    pub fn new() -> TransactionList {
        unsafe {
            from_glib_full(ffi::pk_transaction_list_new())
        }
    }
}

#[cfg(feature = "v0_5_3")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
impl Default for TransactionList {
                     fn default() -> Self {
                         Self::new()
                     }
                 }

mod sealed {
    pub trait Sealed {}
    impl<T: super::IsA<super::TransactionList>> Sealed for T {}
}

/// Trait containing all [`struct@TransactionList`] methods.
///
/// # Implementors
///
/// [`TransactionList`][struct@crate::TransactionList]
pub trait TransactionListExt: IsA<TransactionList> + sealed::Sealed + 'static {
    /// Gets the string lists of transaction IDs recognised as pending, running or finished by the daemon.
    ///
    /// # Returns
    ///
    /// the array of strings, free with `g_strfreev()`
    #[cfg(feature = "v0_5_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
    #[doc(alias = "pk_transaction_list_get_ids")]
    #[doc(alias = "get_ids")]
    fn ids(&self) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::pk_transaction_list_get_ids(self.as_ref().to_glib_none().0))
        }
    }

    /// The ::added signal is emitted when a tid has been added to the transaction list
    /// ## `tid`
    /// the transaction id
    #[doc(alias = "added")]
    fn connect_added<F: Fn(&Self, &str) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn added_trampoline<P: IsA<TransactionList>, F: Fn(&P, &str) + 'static>(this: *mut ffi::PkTransactionList, tid: *mut libc::c_char, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(TransactionList::from_glib_borrow(this).unsafe_cast_ref(), &glib::GString::from_glib_borrow(tid))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"added\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(added_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    /// The ::removed signal is emitted when a tid has been removed from the transaction list
    /// ## `tid`
    /// the transaction id
    #[doc(alias = "removed")]
    fn connect_removed<F: Fn(&Self, &str) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn removed_trampoline<P: IsA<TransactionList>, F: Fn(&P, &str) + 'static>(this: *mut ffi::PkTransactionList, tid: *mut libc::c_char, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(TransactionList::from_glib_borrow(this).unsafe_cast_ref(), &glib::GString::from_glib_borrow(tid))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"removed\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(removed_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl<O: IsA<TransactionList>> TransactionListExt for O {}
