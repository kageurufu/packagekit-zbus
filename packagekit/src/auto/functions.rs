// Generated by gir (https://github.com/gtk-rs/gir @ 1c7a6b57a5fc)
// from gir-files (https://github.com/gtk-rs/gir-files.git @ 21b29d0e0c1a)
// from packagekit-gir-files
// DO NOT EDIT

use crate::{OfflineAction,Results};
#[cfg(feature = "v0_5")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
use crate::{AuthorizeEnum};
#[cfg(feature = "v0_5_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
use crate::{Bitfield};
#[cfg(feature = "v0_9_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_9_6")))]
use crate::{PackageSack};
#[cfg(feature = "v1_2_5")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2_5")))]
use crate::{OfflineFlags};
use glib::{prelude::*,translate::*};


/// Converts a text enumerated type to its unsigned integer representation
/// ## `authorize_type`
/// Text describing the enumerated type
///
/// # Returns
///
/// the enumerated constant value, e.g. [`AuthorizeEnum::Yes`][crate::AuthorizeEnum::Yes]
#[cfg(feature = "v0_5")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
#[doc(alias = "pk_authorize_type_enum_from_string")]
pub fn authorize_type_enum_from_string(authorize_type: &str) -> AuthorizeEnum {
    unsafe {
        from_glib(ffi::pk_authorize_type_enum_from_string(authorize_type.to_glib_none().0))
    }
}

/// Converts a enumerated type to its text representation
/// ## `authorize_type`
/// The enumerated type value
///
/// # Returns
///
/// the enumerated constant value, e.g. "yes"
#[cfg(feature = "v0_5")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5")))]
#[doc(alias = "pk_authorize_type_enum_to_string")]
pub fn authorize_type_enum_to_string(authorize_type: AuthorizeEnum) -> Option<glib::GString> {
    unsafe {
        from_glib_none(ffi::pk_authorize_type_enum_to_string(authorize_type.into_glib()))
    }
}

//#[cfg(feature = "v0_5_2")]
//#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
//#[doc(alias = "pk_bitfield_contain_priority")]
//pub fn bitfield_contain_priority(values: Bitfield, value: i32, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> i32 {
//    unsafe { TODO: call ffi:pk_bitfield_contain_priority() }
//}

//#[cfg(feature = "v0_5_2")]
//#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
//#[doc(alias = "pk_bitfield_from_enums")]
//pub fn bitfield_from_enums(value: i32, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> Bitfield {
//    unsafe { TODO: call ffi:pk_bitfield_from_enums() }
//}

/// Add a log domain to the debug output.
/// ## `log_domain`
/// a log domain
#[doc(alias = "pk_debug_add_log_domain")]
pub fn debug_add_log_domain(log_domain: &str) {
    unsafe {
        ffi::pk_debug_add_log_domain(log_domain.to_glib_none().0);
    }
}

//#[doc(alias = "pk_debug_get_option_group")]
//pub fn debug_get_option_group() -> /*Ignored*/Option<glib::OptionGroup> {
//    unsafe { TODO: call ffi:pk_debug_get_option_group() }
//}

/// Check if verbose debugging is enabled.
///
/// # Returns
///
/// [`true`] if we have debugging enabled
#[doc(alias = "pk_debug_is_verbose")]
pub fn debug_is_verbose() -> bool {
    unsafe {
        from_glib(ffi::pk_debug_is_verbose())
    }
}

/// Set if verbose debugging is enabled.
/// ## `verbose`
/// [`true`] if verbose debugging should be enabled.
#[doc(alias = "pk_debug_set_verbose")]
pub fn debug_set_verbose(verbose: bool) {
    unsafe {
        ffi::pk_debug_set_verbose(verbose.into_glib());
    }
}

//#[doc(alias = "pk_enum_find_string")]
//pub fn enum_find_string(table: /*Ignored*/&EnumMatch, value: u32) -> Option<glib::GString> {
//    unsafe { TODO: call ffi:pk_enum_find_string() }
//}

//#[doc(alias = "pk_enum_find_value")]
//pub fn enum_find_value(table: /*Ignored*/&EnumMatch, string: &str) -> u32 {
//    unsafe { TODO: call ffi:pk_enum_find_value() }
//}

/// Converts text representation to its enumerated type bitfield, or 0 for invalid
/// ## `filters`
/// the enumerated constant value, e.g. "available;~gui"
///
/// # Returns
///
/// The enumerated type values
#[cfg(feature = "v0_5_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
#[doc(alias = "pk_filter_bitfield_from_string")]
pub fn filter_bitfield_from_string(filters: &str) -> Bitfield {
    unsafe {
        ffi::pk_filter_bitfield_from_string(filters.to_glib_none().0)
    }
}

/// Converts a enumerated type bitfield to its text representation
/// ## `filters`
/// The enumerated type values
///
/// # Returns
///
/// the enumerated constant value, e.g. "available;~gui"
#[cfg(feature = "v0_5_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
#[doc(alias = "pk_filter_bitfield_to_string")]
pub fn filter_bitfield_to_string(filters: Bitfield) -> Option<glib::GString> {
    unsafe {
        from_glib_full(ffi::pk_filter_bitfield_to_string(filters))
    }
}

/// Get the distribution ID for the current host, typically "distro;version;arch"
///
/// # Returns
///
/// a distribution ID
#[doc(alias = "pk_get_distro_id")]
#[doc(alias = "get_distro_id")]
pub fn distro_id() -> Option<glib::GString> {
    unsafe {
        from_glib_full(ffi::pk_get_distro_id())
    }
}

/// Converts text representation to its enumerated type bitfield
/// ## `groups`
/// the enumerated constant value, e.g. "available;~gui"
///
/// # Returns
///
/// The enumerated type values, or 0 for invalid
#[cfg(feature = "v0_5_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
#[doc(alias = "pk_group_bitfield_from_string")]
pub fn group_bitfield_from_string(groups: &str) -> Bitfield {
    unsafe {
        ffi::pk_group_bitfield_from_string(groups.to_glib_none().0)
    }
}

/// Converts a enumerated type bitfield to its text representation
/// ## `groups`
/// The enumerated type values
///
/// # Returns
///
/// the enumerated constant value, e.g. "gnome;kde"
#[cfg(feature = "v0_5_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
#[doc(alias = "pk_group_bitfield_to_string")]
pub fn group_bitfield_to_string(groups: Bitfield) -> Option<glib::GString> {
    unsafe {
        from_glib_full(ffi::pk_group_bitfield_to_string(groups))
    }
}

/// Convert a date into an ISO8601 data string.
/// ## `date`
/// a [`glib::Date`][crate::glib::Date] to convert
///
/// # Returns
///
/// If valid then a new ISO8601 date, else [`None`]
#[cfg(feature = "v0_5_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
#[doc(alias = "pk_iso8601_from_date")]
pub fn iso8601_from_date(date: &glib::Date) -> Option<glib::GString> {
    unsafe {
        from_glib_full(ffi::pk_iso8601_from_date(date.to_glib_none().0))
    }
}

/// Get the current date / time as an ISO8601 string.
///
/// # Returns
///
/// The current iso8601 date and time
#[cfg(feature = "v0_5_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
#[doc(alias = "pk_iso8601_present")]
pub fn iso8601_present() -> Option<glib::GString> {
    unsafe {
        from_glib_full(ffi::pk_iso8601_present())
    }
}

/// Convert an ISO8601 date string to a [`glib::Date`][crate::glib::Date].
/// ## `iso_date`
/// The ISO8601 date to convert
///
/// # Returns
///
/// If valid then a new `GDate`, else NULL
#[cfg(feature = "v0_5_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
#[doc(alias = "pk_iso8601_to_date")]
pub fn iso8601_to_date(iso_date: &str) -> Option<glib::Date> {
    unsafe {
        from_glib_full(ffi::pk_iso8601_to_date(iso_date.to_glib_none().0))
    }
}

/// Convert an ISO8601 date string to a [`glib::DateTime`][crate::glib::DateTime].
/// ## `iso_date`
/// The ISO8601 date to convert
///
/// # Returns
///
/// If valid then a new `GDateTime`, else NULL
#[cfg(feature = "v0_8_11")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_11")))]
#[doc(alias = "pk_iso8601_to_datetime")]
pub fn iso8601_to_datetime(iso_date: &str) -> Option<glib::DateTime> {
    unsafe {
        from_glib_full(ffi::pk_iso8601_to_datetime(iso_date.to_glib_none().0))
    }
}

#[doc(alias = "pk_offline_auth_cancel")]
pub fn offline_auth_cancel() -> Result<(), glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let is_ok = ffi::pk_offline_auth_cancel(&mut error);
        debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
    }
}

#[doc(alias = "pk_offline_auth_clear_results")]
pub fn offline_auth_clear_results() -> Result<(), glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let is_ok = ffi::pk_offline_auth_clear_results(&mut error);
        debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
    }
}

#[doc(alias = "pk_offline_auth_invalidate")]
pub fn offline_auth_invalidate() -> Result<(), glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let is_ok = ffi::pk_offline_auth_invalidate(&mut error);
        debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
    }
}

#[doc(alias = "pk_offline_auth_set_action")]
pub fn offline_auth_set_action(action: OfflineAction) -> Result<(), glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let is_ok = ffi::pk_offline_auth_set_action(action.into_glib(), &mut error);
        debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
    }
}

#[doc(alias = "pk_offline_auth_set_prepared_upgrade")]
pub fn offline_auth_set_prepared_upgrade(name: &str, release_ver: &str) -> Result<(), glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let is_ok = ffi::pk_offline_auth_set_prepared_upgrade(name.to_glib_none().0, release_ver.to_glib_none().0, &mut error);
        debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
    }
}

#[doc(alias = "pk_offline_auth_set_results")]
pub fn offline_auth_set_results(results: &impl IsA<Results>) -> Result<(), glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let is_ok = ffi::pk_offline_auth_set_results(results.as_ref().to_glib_none().0, &mut error);
        debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
    }
}

#[doc(alias = "pk_offline_auth_trigger")]
pub fn offline_auth_trigger(action: OfflineAction) -> Result<(), glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let is_ok = ffi::pk_offline_auth_trigger(action.into_glib(), &mut error);
        debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
    }
}

#[doc(alias = "pk_offline_auth_trigger_upgrade")]
pub fn offline_auth_trigger_upgrade(action: OfflineAction) -> Result<(), glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let is_ok = ffi::pk_offline_auth_trigger_upgrade(action.into_glib(), &mut error);
        debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
    }
}

/// Cancels the offline operation that has been scheduled. If there is no
/// scheduled offline operation then this method returns with success.
/// The function always allows user interaction. To change the behavior,
/// use [`offline_cancel_with_flags()`][crate::offline_cancel_with_flags()].
/// ## `cancellable`
/// A [`gio::Cancellable`][crate::gio::Cancellable] or [`None`]
///
/// # Returns
///
/// [`true`] for success, else [`false`] and `error` set
#[cfg(feature = "v0_9_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_9_6")))]
#[doc(alias = "pk_offline_cancel")]
pub fn offline_cancel(cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(), glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let is_ok = ffi::pk_offline_cancel(cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
        debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
    }
}

/// Cancels the offline operation that has been scheduled. If there is no
/// scheduled offline operation then this method returns with success.
/// ## `flags`
/// bit-or of [`OfflineFlags`][crate::OfflineFlags]
/// ## `cancellable`
/// A [`gio::Cancellable`][crate::gio::Cancellable] or [`None`]
///
/// # Returns
///
/// [`true`] for success, else [`false`] and `error` set
#[cfg(feature = "v1_2_5")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2_5")))]
#[doc(alias = "pk_offline_cancel_with_flags")]
pub fn offline_cancel_with_flags(flags: OfflineFlags, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(), glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let is_ok = ffi::pk_offline_cancel_with_flags(flags.into_glib(), cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
        debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
    }
}

/// Clears the last offline operation report, which may be success or failure.
/// If the report does not exist then this method returns success.
/// The function always allows user interaction. To change the behavior,
/// use [`offline_clear_results_with_flags()`][crate::offline_clear_results_with_flags()].
/// ## `cancellable`
/// A [`gio::Cancellable`][crate::gio::Cancellable] or [`None`]
///
/// # Returns
///
/// [`true`] for success, else [`false`] and `error` set
#[cfg(feature = "v0_9_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_9_6")))]
#[doc(alias = "pk_offline_clear_results")]
pub fn offline_clear_results(cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(), glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let is_ok = ffi::pk_offline_clear_results(cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
        debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
    }
}

/// Clears the last offline operation report, which may be success or failure.
/// If the report does not exist then this method returns success.
/// ## `flags`
/// bit-or of [`OfflineFlags`][crate::OfflineFlags]
/// ## `cancellable`
/// A [`gio::Cancellable`][crate::gio::Cancellable] or [`None`]
///
/// # Returns
///
/// [`true`] for success, else [`false`] and `error` set
#[cfg(feature = "v1_2_5")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2_5")))]
#[doc(alias = "pk_offline_clear_results_with_flags")]
pub fn offline_clear_results_with_flags(flags: OfflineFlags, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(), glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let is_ok = ffi::pk_offline_clear_results_with_flags(flags.into_glib(), cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
        debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
    }
}

/// Gets the action that will be taken after the offline action has completed.
///
/// An error is set if the the value [`OfflineAction::Unknown`][crate::OfflineAction::Unknown] is returned.
///
/// # Returns
///
/// a [`OfflineAction`][crate::OfflineAction], e.g. [`OfflineAction::Reboot`][crate::OfflineAction::Reboot]
#[cfg(feature = "v0_9_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_9_6")))]
#[doc(alias = "pk_offline_get_action")]
pub fn offline_get_action() -> Result<OfflineAction, glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let ret = ffi::pk_offline_get_action(&mut error);
        if error.is_null() { Ok(from_glib(ret)) } else { Err(from_glib_full(error)) }
    }
}

/// Gets a file monitor for the trigger.
/// ## `cancellable`
/// A [`gio::Cancellable`][crate::gio::Cancellable] or [`None`]
///
/// # Returns
///
/// A [`gio::FileMonitor`][crate::gio::FileMonitor], or [`None`]
#[cfg(feature = "v0_9_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_9_6")))]
#[doc(alias = "pk_offline_get_action_monitor")]
pub fn offline_get_action_monitor(cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<gio::FileMonitor, glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let ret = ffi::pk_offline_get_action_monitor(cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
        if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
    }
}

/// Gets the package-ids in the prepared transaction.
///
/// # Returns
///
/// array of package-ids, or [`None`]
#[cfg(feature = "v0_9_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_9_6")))]
#[doc(alias = "pk_offline_get_prepared_ids")]
pub fn offline_get_prepared_ids() -> Result<Vec<glib::GString>, glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let ret = ffi::pk_offline_get_prepared_ids(&mut error);
        if error.is_null() { Ok(FromGlibPtrContainer::from_glib_full(ret)) } else { Err(from_glib_full(error)) }
    }
}

/// Gets a file monitor for the prepared transaction.
/// ## `cancellable`
/// A [`gio::Cancellable`][crate::gio::Cancellable] or [`None`]
///
/// # Returns
///
/// A [`gio::FileMonitor`][crate::gio::FileMonitor], or [`None`]
#[cfg(feature = "v0_9_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_9_6")))]
#[doc(alias = "pk_offline_get_prepared_monitor")]
pub fn offline_get_prepared_monitor(cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<gio::FileMonitor, glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let ret = ffi::pk_offline_get_prepared_monitor(cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
        if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
    }
}

/// Gets a package sack of the packages in the prepared transaction.
///
/// # Returns
///
/// A new [`PackageSack`][crate::PackageSack], or [`None`]
#[cfg(feature = "v0_9_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_9_6")))]
#[doc(alias = "pk_offline_get_prepared_sack")]
pub fn offline_get_prepared_sack() -> Result<PackageSack, glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let ret = ffi::pk_offline_get_prepared_sack(&mut error);
        if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
    }
}

/// Gets a file monitor for the prepared system upgrade transaction.
/// ## `cancellable`
/// A [`gio::Cancellable`][crate::gio::Cancellable] or [`None`]
///
/// # Returns
///
/// A [`gio::FileMonitor`][crate::gio::FileMonitor], or [`None`]
#[cfg(feature = "v1_0_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_0_12")))]
#[doc(alias = "pk_offline_get_prepared_upgrade_monitor")]
pub fn offline_get_prepared_upgrade_monitor(cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<gio::FileMonitor, glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let ret = ffi::pk_offline_get_prepared_upgrade_monitor(cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
        if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
    }
}

/// Gets the name of the prepared system upgrade in the prepared transaction.
///
/// # Returns
///
/// the name, or [`None`] if unset, free with `g_free()`
#[cfg(feature = "v1_1_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_1_2")))]
#[doc(alias = "pk_offline_get_prepared_upgrade_name")]
pub fn offline_get_prepared_upgrade_name() -> Result<glib::GString, glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let ret = ffi::pk_offline_get_prepared_upgrade_name(&mut error);
        if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
    }
}

/// Gets the version of the prepared system upgrade in the prepared transaction.
///
/// # Returns
///
/// the version, or [`None`] if unset, free with `g_free()`
#[cfg(feature = "v1_0_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_0_12")))]
#[doc(alias = "pk_offline_get_prepared_upgrade_version")]
pub fn offline_get_prepared_upgrade_version() -> Result<glib::GString, glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let ret = ffi::pk_offline_get_prepared_upgrade_version(&mut error);
        if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
    }
}

/// Gets the last result of the offline transaction.
///
/// # Returns
///
/// A [`Results`][crate::Results], or [`None`]
#[cfg(feature = "v0_9_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_9_6")))]
#[doc(alias = "pk_offline_get_results")]
pub fn offline_get_results() -> Result<Results, glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let ret = ffi::pk_offline_get_results(&mut error);
        if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
    }
}

/// Gets the modification time of the prepared transaction.
///
/// # Returns
///
/// a unix time, or 0 for error.
#[cfg(feature = "v0_9_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_9_6")))]
#[doc(alias = "pk_offline_get_results_mtime")]
pub fn offline_get_results_mtime() -> Result<u64, glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let ret = ffi::pk_offline_get_results_mtime(&mut error);
        if error.is_null() { Ok(ret) } else { Err(from_glib_full(error)) }
    }
}

/// Triggers the offline update so that the next reboot will perform the
/// pending transaction.
/// The function always allows user interaction. To change the behavior,
/// use [`offline_trigger_with_flags()`][crate::offline_trigger_with_flags()].
/// ## `action`
/// a [`OfflineAction`][crate::OfflineAction], e.g. [`OfflineAction::Reboot`][crate::OfflineAction::Reboot]
/// ## `cancellable`
/// A [`gio::Cancellable`][crate::gio::Cancellable] or [`None`]
///
/// # Returns
///
/// [`true`] for success, else [`false`] and `error` set
#[cfg(feature = "v0_9_6")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_9_6")))]
#[doc(alias = "pk_offline_trigger")]
pub fn offline_trigger(action: OfflineAction, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(), glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let is_ok = ffi::pk_offline_trigger(action.into_glib(), cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
        debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
    }
}

/// Triggers the offline system upgrade so that the next reboot will perform the
/// pending transaction.
/// The function always allows user interaction. To change the behavior,
/// use [`offline_trigger_upgrade_with_flags()`][crate::offline_trigger_upgrade_with_flags()].
/// ## `action`
/// a [`OfflineAction`][crate::OfflineAction], e.g. [`OfflineAction::Reboot`][crate::OfflineAction::Reboot]
/// ## `cancellable`
/// A [`gio::Cancellable`][crate::gio::Cancellable] or [`None`]
///
/// # Returns
///
/// [`true`] for success, else [`false`] and `error` set
#[cfg(feature = "v1_0_12")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_0_12")))]
#[doc(alias = "pk_offline_trigger_upgrade")]
pub fn offline_trigger_upgrade(action: OfflineAction, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(), glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let is_ok = ffi::pk_offline_trigger_upgrade(action.into_glib(), cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
        debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
    }
}

/// Triggers the offline system upgrade so that the next reboot will perform the
/// pending transaction.
/// ## `action`
/// a [`OfflineAction`][crate::OfflineAction], e.g. [`OfflineAction::Reboot`][crate::OfflineAction::Reboot]
/// ## `flags`
/// bit-or of [`OfflineFlags`][crate::OfflineFlags]
/// ## `cancellable`
/// A [`gio::Cancellable`][crate::gio::Cancellable] or [`None`]
///
/// # Returns
///
/// [`true`] for success, else [`false`] and `error` set
#[cfg(feature = "v1_2_5")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2_5")))]
#[doc(alias = "pk_offline_trigger_upgrade_with_flags")]
pub fn offline_trigger_upgrade_with_flags(action: OfflineAction, flags: OfflineFlags, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(), glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let is_ok = ffi::pk_offline_trigger_upgrade_with_flags(action.into_glib(), flags.into_glib(), cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
        debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
    }
}

/// Triggers the offline update so that the next reboot will perform the
/// pending transaction.
/// ## `action`
/// a [`OfflineAction`][crate::OfflineAction], e.g. [`OfflineAction::Reboot`][crate::OfflineAction::Reboot]
/// ## `flags`
/// bit-or of [`OfflineFlags`][crate::OfflineFlags]
/// ## `cancellable`
/// A [`gio::Cancellable`][crate::gio::Cancellable] or [`None`]
///
/// # Returns
///
/// [`true`] for success, else [`false`] and `error` set
#[cfg(feature = "v1_2_5")]
#[cfg_attr(docsrs, doc(cfg(feature = "v1_2_5")))]
#[doc(alias = "pk_offline_trigger_with_flags")]
pub fn offline_trigger_with_flags(action: OfflineAction, flags: OfflineFlags, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(), glib::Error> {
    unsafe {
        let mut error = std::ptr::null_mut();
        let is_ok = ffi::pk_offline_trigger_with_flags(action.into_glib(), flags.into_glib(), cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
        debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
        if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
    }
}

#[doc(alias = "pk_polkit_agent_close")]
pub fn polkit_agent_close() {
    unsafe {
        ffi::pk_polkit_agent_close();
    }
}

#[doc(alias = "pk_polkit_agent_open")]
pub fn polkit_agent_open() -> i32 {
    unsafe {
        ffi::pk_polkit_agent_open()
    }
}

/// Form a composite string array of strings.
/// The data in the GPtrArray is copied.
/// ## `array`
/// the GPtrArray of strings
///
/// # Returns
///
/// the string array, or [`None`] if invalid
#[cfg(feature = "v0_5_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
#[doc(alias = "pk_ptr_array_to_strv")]
pub fn ptr_array_to_strv(array: &[&str]) -> Vec<glib::GString> {
    unsafe {
        FromGlibPtrContainer::from_glib_full(ffi::pk_ptr_array_to_strv(array.to_glib_none().0))
    }
}

/// Converts text representation to its enumerated type bitfield
/// ## `roles`
/// the enumerated constant value, e.g. "search-file;update-system"
///
/// # Returns
///
/// The enumerated type values, or 0 for invalid
#[cfg(feature = "v0_5_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
#[doc(alias = "pk_role_bitfield_from_string")]
pub fn role_bitfield_from_string(roles: &str) -> Bitfield {
    unsafe {
        ffi::pk_role_bitfield_from_string(roles.to_glib_none().0)
    }
}

/// Converts a enumerated type bitfield to its text representation
/// ## `roles`
/// The enumerated type values
///
/// # Returns
///
/// the enumerated constant value, e.g. "install-file;update-system"
#[cfg(feature = "v0_5_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
#[doc(alias = "pk_role_bitfield_to_string")]
pub fn role_bitfield_to_string(roles: Bitfield) -> Option<glib::GString> {
    unsafe {
        from_glib_full(ffi::pk_role_bitfield_to_string(roles))
    }
}

/// Converts text representation to its enumerated type bitfield, or 0 for invalid
/// ## `transaction_flags`
/// the enumerated constant value, e.g. "only-trusted;simulate"
///
/// # Returns
///
/// The enumerated type values
#[cfg(feature = "v0_8_1")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_1")))]
#[doc(alias = "pk_transaction_flag_bitfield_from_string")]
pub fn transaction_flag_bitfield_from_string(transaction_flags: &str) -> Bitfield {
    unsafe {
        ffi::pk_transaction_flag_bitfield_from_string(transaction_flags.to_glib_none().0)
    }
}

/// Converts a enumerated type bitfield to its text representation
/// ## `transaction_flags`
/// The enumerated type values
///
/// # Returns
///
/// the enumerated constant value, e.g. "only-trusted;simulate"
#[cfg(feature = "v0_8_1")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_1")))]
#[doc(alias = "pk_transaction_flag_bitfield_to_string")]
pub fn transaction_flag_bitfield_to_string(transaction_flags: Bitfield) -> Option<glib::GString> {
    unsafe {
        from_glib_full(ffi::pk_transaction_flag_bitfield_to_string(transaction_flags))
    }
}
