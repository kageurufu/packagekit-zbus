// Generated by gir (https://github.com/gtk-rs/gir @ 1c7a6b57a5fc)
// from gir-files (https://github.com/gtk-rs/gir-files.git @ 21b29d0e0c1a)
// from packagekit-gir-files
// DO NOT EDIT

#[cfg(feature = "v0_5_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
use crate::{Package,RoleEnum,StatusEnum};
#[cfg(feature = "v0_8_1")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_1")))]
use crate::{ItemProgress};
use glib::{prelude::*};
#[cfg(feature = "v0_5_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
use glib::{signal::{connect_raw, SignalHandlerId},translate::*};
#[cfg(feature = "v0_5_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
use std::{boxed::Box as Box_};

glib::wrapper! {
    #[doc(alias = "PkProgress")]
    pub struct Progress(Object<ffi::PkProgress, ffi::PkProgressClass>);

    match fn {
        type_ => || ffi::pk_progress_get_type(),
    }
}

impl Progress {
        pub const NONE: Option<&'static Progress> = None;
    

    /// [`Progress`][crate::Progress] is a nice GObject wrapper for PackageKit and makes writing
    /// frontends easy.
    ///
    /// # Returns
    ///
    /// A new [`Progress`][crate::Progress] instance
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_progress_new")]
    pub fn new() -> Progress {
        unsafe {
            from_glib_full(ffi::pk_progress_new())
        }
    }
}

#[cfg(feature = "v0_5_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
impl Default for Progress {
                     fn default() -> Self {
                         Self::new()
                     }
                 }

mod sealed {
    pub trait Sealed {}
    impl<T: super::IsA<super::Progress>> Sealed for T {}
}

/// Trait containing all [`struct@Progress`] methods.
///
/// # Implementors
///
/// [`Progress`][struct@crate::Progress]
pub trait ProgressExt: IsA<Progress> + sealed::Sealed + 'static {
    /// Get if this transaction can be cancelled.
    ///
    /// # Returns
    ///
    /// [`true`] if progress can be cancelled.
    #[cfg(feature = "v1_0_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_0_12")))]
    #[doc(alias = "pk_progress_get_allow_cancel")]
    #[doc(alias = "get_allow_cancel")]
    fn allows_cancel(&self) -> bool {
        unsafe {
            from_glib(ffi::pk_progress_get_allow_cancel(self.as_ref().to_glib_none().0))
        }
    }

    /// Get if the transaction caller is connected.
    ///
    /// # Returns
    ///
    /// [`true`] if the transaction caller is still connected.
    #[cfg(feature = "v1_0_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_0_12")))]
    #[doc(alias = "pk_progress_get_caller_active")]
    #[doc(alias = "get_caller_active")]
    fn is_caller_active(&self) -> bool {
        unsafe {
            from_glib(ffi::pk_progress_get_caller_active(self.as_ref().to_glib_none().0))
        }
    }

    /// Get the number of bytes remaining to download.
    ///
    /// # Returns
    ///
    /// number of bytes remaining to download.
    #[cfg(feature = "v1_0_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_0_12")))]
    #[doc(alias = "pk_progress_get_download_size_remaining")]
    #[doc(alias = "get_download_size_remaining")]
    fn download_size_remaining(&self) -> u64 {
        unsafe {
            ffi::pk_progress_get_download_size_remaining(self.as_ref().to_glib_none().0)
        }
    }

    /// Get the amount of time the transaction has taken.
    ///
    /// # Returns
    ///
    /// time in seconds
    #[cfg(feature = "v1_0_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_0_12")))]
    #[doc(alias = "pk_progress_get_elapsed_time")]
    #[doc(alias = "get_elapsed_time")]
    fn elapsed_time(&self) -> u32 {
        unsafe {
            ffi::pk_progress_get_elapsed_time(self.as_ref().to_glib_none().0)
        }
    }

    /// Get the item progress associated with this transaction.
    ///
    /// # Returns
    ///
    /// a [`ItemProgress`][crate::ItemProgress]
    #[cfg(feature = "v1_0_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_0_12")))]
    #[doc(alias = "pk_progress_get_item_progress")]
    #[doc(alias = "get_item_progress")]
    fn item_progress(&self) -> Option<ItemProgress> {
        unsafe {
            from_glib_none(ffi::pk_progress_get_item_progress(self.as_ref().to_glib_none().0))
        }
    }

    /// Get the package this transaction is acting on.
    ///
    /// # Returns
    ///
    /// a [`Package`][crate::Package]
    #[cfg(feature = "v1_0_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_0_12")))]
    #[doc(alias = "pk_progress_get_package")]
    #[doc(alias = "get_package")]
    fn package(&self) -> Option<Package> {
        unsafe {
            from_glib_none(ffi::pk_progress_get_package(self.as_ref().to_glib_none().0))
        }
    }

    /// Get the package ID this transaction is acting on.
    ///
    /// # Returns
    ///
    /// a PackageID
    #[cfg(feature = "v1_0_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_0_12")))]
    #[doc(alias = "pk_progress_get_package_id")]
    #[doc(alias = "get_package_id")]
    fn package_id(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::pk_progress_get_package_id(self.as_ref().to_glib_none().0))
        }
    }

    /// Get the percentage complete.
    ///
    /// # Returns
    ///
    /// a percentage (0-100)
    #[cfg(feature = "v1_0_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_0_12")))]
    #[doc(alias = "pk_progress_get_percentage")]
    #[doc(alias = "get_percentage")]
    fn percentage(&self) -> i32 {
        unsafe {
            ffi::pk_progress_get_percentage(self.as_ref().to_glib_none().0)
        }
    }

    /// Get the amount of time the transaction will take to complete.
    ///
    /// # Returns
    ///
    /// time in seconds or 0 if unknown.
    #[cfg(feature = "v1_0_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_0_12")))]
    #[doc(alias = "pk_progress_get_remaining_time")]
    #[doc(alias = "get_remaining_time")]
    fn remaining_time(&self) -> u32 {
        unsafe {
            ffi::pk_progress_get_remaining_time(self.as_ref().to_glib_none().0)
        }
    }

    /// Get the role of this transaction.
    ///
    /// # Returns
    ///
    /// a [`RoleEnum`][crate::RoleEnum]
    #[cfg(feature = "v1_0_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_0_12")))]
    #[doc(alias = "pk_progress_get_role")]
    #[doc(alias = "get_role")]
    fn role(&self) -> RoleEnum {
        unsafe {
            from_glib(ffi::pk_progress_get_role(self.as_ref().to_glib_none().0))
        }
    }

    /// Get the speed of this transaction.
    ///
    /// # Returns
    ///
    /// speed in bits per scond or 0 if unknown
    #[cfg(feature = "v1_0_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_0_12")))]
    #[doc(alias = "pk_progress_get_speed")]
    #[doc(alias = "get_speed")]
    fn speed(&self) -> u32 {
        unsafe {
            ffi::pk_progress_get_speed(self.as_ref().to_glib_none().0)
        }
    }

    /// Get the status of this transaction.
    ///
    /// # Returns
    ///
    /// a status string
    #[cfg(feature = "v1_0_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_0_12")))]
    #[doc(alias = "pk_progress_get_status")]
    #[doc(alias = "get_status")]
    fn status(&self) -> StatusEnum {
        unsafe {
            from_glib(ffi::pk_progress_get_status(self.as_ref().to_glib_none().0))
        }
    }

    /// Get the flags associated with this transaction.
    ///
    /// # Returns
    ///
    /// a `PkBitfield` containing [`TransactionFlagEnum`][crate::TransactionFlagEnum] values.
    #[cfg(feature = "v1_0_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_0_12")))]
    #[doc(alias = "pk_progress_get_transaction_flags")]
    #[doc(alias = "get_transaction_flags")]
    fn transaction_flags(&self) -> u64 {
        unsafe {
            ffi::pk_progress_get_transaction_flags(self.as_ref().to_glib_none().0)
        }
    }

    /// Get the ID used by this transaction.
    ///
    /// # Returns
    ///
    /// a transaction ID.
    #[cfg(feature = "v1_0_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_0_12")))]
    #[doc(alias = "pk_progress_get_transaction_id")]
    #[doc(alias = "get_transaction_id")]
    fn transaction_id(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::pk_progress_get_transaction_id(self.as_ref().to_glib_none().0))
        }
    }

    /// Get the UID that started this transaction.
    ///
    /// # Returns
    ///
    /// an UID
    #[cfg(feature = "v1_0_12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_0_12")))]
    #[doc(alias = "pk_progress_get_uid")]
    #[doc(alias = "get_uid")]
    fn uid(&self) -> u32 {
        unsafe {
            ffi::pk_progress_get_uid(self.as_ref().to_glib_none().0)
        }
    }

    /// Set if this transaction can be cancelled.
    /// ## `allow_cancel`
    /// [`true`] if this transaction can be cancelled.
    ///
    /// # Returns
    ///
    /// [`true`] if value changed.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_progress_set_allow_cancel")]
    fn set_allow_cancel(&self, allow_cancel: bool) -> bool {
        unsafe {
            from_glib(ffi::pk_progress_set_allow_cancel(self.as_ref().to_glib_none().0, allow_cancel.into_glib()))
        }
    }

    /// Set if the transaction caller is connected.
    /// ## `caller_active`
    /// [`true`] if the transaction caller is still connected.
    ///
    /// # Returns
    ///
    /// [`true`] if value changed.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_progress_set_caller_active")]
    fn set_caller_active(&self, caller_active: bool) -> bool {
        unsafe {
            from_glib(ffi::pk_progress_set_caller_active(self.as_ref().to_glib_none().0, caller_active.into_glib()))
        }
    }

    /// Set the number of bytes remaining to download.
    /// ## `download_size_remaining`
    /// number of bytes remaining to download.
    ///
    /// # Returns
    ///
    /// [`true`] if value changed.
    #[cfg(feature = "v0_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_8")))]
    #[doc(alias = "pk_progress_set_download_size_remaining")]
    fn set_download_size_remaining(&self, download_size_remaining: u64) -> bool {
        unsafe {
            from_glib(ffi::pk_progress_set_download_size_remaining(self.as_ref().to_glib_none().0, download_size_remaining))
        }
    }

    /// Set the amount of time the transaction has taken.
    /// ## `elapsed_time`
    /// time in seconds
    ///
    /// # Returns
    ///
    /// [`true`] if value changed.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_progress_set_elapsed_time")]
    fn set_elapsed_time(&self, elapsed_time: u32) -> bool {
        unsafe {
            from_glib(ffi::pk_progress_set_elapsed_time(self.as_ref().to_glib_none().0, elapsed_time))
        }
    }

    /// Set the item progress associated with this transaction.
    /// ## `item_progress`
    /// a [`ItemProgress`][crate::ItemProgress]
    ///
    /// # Returns
    ///
    /// [`true`] if value changed.
    #[cfg(feature = "v0_8_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_8_1")))]
    #[doc(alias = "pk_progress_set_item_progress")]
    fn set_item_progress(&self, item_progress: &impl IsA<ItemProgress>) -> bool {
        unsafe {
            from_glib(ffi::pk_progress_set_item_progress(self.as_ref().to_glib_none().0, item_progress.as_ref().to_glib_none().0))
        }
    }

    /// Set the package this transaction is acting on.
    /// ## `package`
    /// a [`Package`][crate::Package]
    ///
    /// # Returns
    ///
    /// [`true`] if value changed.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_progress_set_package")]
    fn set_package(&self, package: &impl IsA<Package>) -> bool {
        unsafe {
            from_glib(ffi::pk_progress_set_package(self.as_ref().to_glib_none().0, package.as_ref().to_glib_none().0))
        }
    }

    /// Set the package ID this transaction is acting on.
    /// ## `package_id`
    /// a PackageID
    ///
    /// # Returns
    ///
    /// [`true`] if value changed.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_progress_set_package_id")]
    fn set_package_id(&self, package_id: &str) -> bool {
        unsafe {
            from_glib(ffi::pk_progress_set_package_id(self.as_ref().to_glib_none().0, package_id.to_glib_none().0))
        }
    }

    /// Set the percentage complete of this transaction.
    /// ## `percentage`
    /// a percentage value (0-100)
    ///
    /// # Returns
    ///
    /// [`true`] if value changed.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_progress_set_percentage")]
    fn set_percentage(&self, percentage: i32) -> bool {
        unsafe {
            from_glib(ffi::pk_progress_set_percentage(self.as_ref().to_glib_none().0, percentage))
        }
    }

    /// Set the amount of time the transaction will take to complete.
    /// ## `remaining_time`
    /// time in seconds or 0 if unknown.
    ///
    /// # Returns
    ///
    /// [`true`] if value changed.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_progress_set_remaining_time")]
    fn set_remaining_time(&self, remaining_time: u32) -> bool {
        unsafe {
            from_glib(ffi::pk_progress_set_remaining_time(self.as_ref().to_glib_none().0, remaining_time))
        }
    }

    /// Set the role of this transaction.
    /// ## `role`
    /// a [`RoleEnum`][crate::RoleEnum]
    ///
    /// # Returns
    ///
    /// [`true`] if value changed.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_progress_set_role")]
    fn set_role(&self, role: RoleEnum) -> bool {
        unsafe {
            from_glib(ffi::pk_progress_set_role(self.as_ref().to_glib_none().0, role.into_glib()))
        }
    }

    /// Set the speed of this transaction.
    /// ## `speed`
    /// speed in bits per second or 0 if unknown
    ///
    /// # Returns
    ///
    /// [`true`] if value changed.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_progress_set_speed")]
    fn set_speed(&self, speed: u32) -> bool {
        unsafe {
            from_glib(ffi::pk_progress_set_speed(self.as_ref().to_glib_none().0, speed))
        }
    }

    /// Set the status of this transaction.
    /// ## `status`
    /// a [`StatusEnum`][crate::StatusEnum]
    ///
    /// # Returns
    ///
    /// [`true`] if value changed.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_progress_set_status")]
    fn set_status(&self, status: StatusEnum) -> bool {
        unsafe {
            from_glib(ffi::pk_progress_set_status(self.as_ref().to_glib_none().0, status.into_glib()))
        }
    }

    /// Set the flags associated with this transaction.
    /// ## `transaction_flags`
    /// a `PkBitfield` containing [`TransactionFlagEnum`][crate::TransactionFlagEnum] values.
    ///
    /// # Returns
    ///
    /// [`true`] if value changed.
    #[cfg(feature = "v0_8_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_8_8")))]
    #[doc(alias = "pk_progress_set_transaction_flags")]
    fn set_transaction_flags(&self, transaction_flags: u64) -> bool {
        unsafe {
            from_glib(ffi::pk_progress_set_transaction_flags(self.as_ref().to_glib_none().0, transaction_flags))
        }
    }

    /// Set the ID used by this transaction.
    /// ## `transaction_id`
    /// a transaction ID.
    ///
    /// # Returns
    ///
    /// [`true`] if value changed.
    #[cfg(feature = "v0_5_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
    #[doc(alias = "pk_progress_set_transaction_id")]
    fn set_transaction_id(&self, transaction_id: &str) -> bool {
        unsafe {
            from_glib(ffi::pk_progress_set_transaction_id(self.as_ref().to_glib_none().0, transaction_id.to_glib_none().0))
        }
    }

    /// Set the UID that started this transaction.
    /// ## `uid`
    /// a UID
    ///
    /// # Returns
    ///
    /// [`true`] if value changed.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_progress_set_uid")]
    fn set_uid(&self, uid: u32) -> bool {
        unsafe {
            from_glib(ffi::pk_progress_set_uid(self.as_ref().to_glib_none().0, uid))
        }
    }

    /// [`true`] if this transaction can be cancelled.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "allow-cancel")]
    fn get_property_allow_cancel(&self) -> bool {
        ObjectExt::property(self.as_ref(), "allow-cancel")
    }

    /// [`true`] if the transaction caller is still connected.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "caller-active")]
    fn get_property_caller_active(&self) -> bool {
        ObjectExt::property(self.as_ref(), "caller-active")
    }

    /// Number of bytes remaining to download.
    #[cfg(feature = "v0_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_8")))]
    #[doc(alias = "download-size-remaining")]
    fn get_property_download_size_remaining(&self) -> u64 {
        ObjectExt::property(self.as_ref(), "download-size-remaining")
    }

    /// Amount of time the transaction has taken in seconds.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "elapsed-time")]
    fn get_property_elapsed_time(&self) -> u32 {
        ObjectExt::property(self.as_ref(), "elapsed-time")
    }

    /// Item progress associated with this transaction.
    #[cfg(feature = "v0_8_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_8_1")))]
    #[doc(alias = "item-progress")]
    fn get_property_item_progress(&self) -> Option<ItemProgress> {
        ObjectExt::property(self.as_ref(), "item-progress")
    }

    /// The package this transaction is acting on.
    #[cfg(feature = "v0_5_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
    fn get_property_package(&self) -> Option<Package> {
        ObjectExt::property(self.as_ref(), "package")
    }

    /// Package ID this transaction is acting on.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "package-id")]
    fn get_property_package_id(&self) -> Option<glib::GString> {
        ObjectExt::property(self.as_ref(), "package-id")
    }

    /// Percentage complete of this transaction.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    fn get_property_percentage(&self) -> i32 {
        ObjectExt::property(self.as_ref(), "percentage")
    }

    /// Amount of time the transaction will take to complete in seconds or 0 if unknown.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "remaining-time")]
    fn get_property_remaining_time(&self) -> u32 {
        ObjectExt::property(self.as_ref(), "remaining-time")
    }

    /// Role of this transaction.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    fn get_property_role(&self) -> u32 {
        ObjectExt::property(self.as_ref(), "role")
    }

    /// Transaction speed in bits per second or 0 if unknown.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    fn get_property_speed(&self) -> u32 {
        ObjectExt::property(self.as_ref(), "speed")
    }

    /// Status of this transaction.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    fn get_property_status(&self) -> u32 {
        ObjectExt::property(self.as_ref(), "status")
    }

    /// A `PkBitfield` containing [`TransactionFlagEnum`][crate::TransactionFlagEnum] associated with this transaction.
    #[cfg(feature = "v0_8_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_8_8")))]
    #[doc(alias = "transaction-flags")]
    fn get_property_transaction_flags(&self) -> u64 {
        ObjectExt::property(self.as_ref(), "transaction-flags")
    }

    /// ID used by this transaction.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "transaction-id")]
    fn get_property_transaction_id(&self) -> Option<glib::GString> {
        ObjectExt::property(self.as_ref(), "transaction-id")
    }

    /// ID used by this transaction.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "transaction-id")]
    fn set_property_transaction_id(&self, transaction_id: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"transaction-id", transaction_id)
    }

    /// The UID that started this transaction.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    fn get_property_uid(&self) -> u32 {
        ObjectExt::property(self.as_ref(), "uid")
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "allow-cancel")]
    fn connect_allow_cancel_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_allow_cancel_trampoline<P: IsA<Progress>, F: Fn(&P) + 'static>(this: *mut ffi::PkProgress, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Progress::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::allow-cancel\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_allow_cancel_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "caller-active")]
    fn connect_caller_active_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_caller_active_trampoline<P: IsA<Progress>, F: Fn(&P) + 'static>(this: *mut ffi::PkProgress, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Progress::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::caller-active\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_caller_active_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_8")))]
    #[doc(alias = "download-size-remaining")]
    fn connect_download_size_remaining_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_download_size_remaining_trampoline<P: IsA<Progress>, F: Fn(&P) + 'static>(this: *mut ffi::PkProgress, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Progress::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::download-size-remaining\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_download_size_remaining_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "elapsed-time")]
    fn connect_elapsed_time_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_elapsed_time_trampoline<P: IsA<Progress>, F: Fn(&P) + 'static>(this: *mut ffi::PkProgress, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Progress::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::elapsed-time\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_elapsed_time_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_8_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_8_1")))]
    #[doc(alias = "item-progress")]
    fn connect_item_progress_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_item_progress_trampoline<P: IsA<Progress>, F: Fn(&P) + 'static>(this: *mut ffi::PkProgress, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Progress::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::item-progress\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_item_progress_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
    #[doc(alias = "package")]
    fn connect_package_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_package_trampoline<P: IsA<Progress>, F: Fn(&P) + 'static>(this: *mut ffi::PkProgress, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Progress::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::package\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_package_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "package-id")]
    fn connect_package_id_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_package_id_trampoline<P: IsA<Progress>, F: Fn(&P) + 'static>(this: *mut ffi::PkProgress, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Progress::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::package-id\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_package_id_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "percentage")]
    fn connect_percentage_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_percentage_trampoline<P: IsA<Progress>, F: Fn(&P) + 'static>(this: *mut ffi::PkProgress, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Progress::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::percentage\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_percentage_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "remaining-time")]
    fn connect_remaining_time_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_remaining_time_trampoline<P: IsA<Progress>, F: Fn(&P) + 'static>(this: *mut ffi::PkProgress, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Progress::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::remaining-time\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_remaining_time_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "role")]
    fn connect_role_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_role_trampoline<P: IsA<Progress>, F: Fn(&P) + 'static>(this: *mut ffi::PkProgress, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Progress::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::role\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_role_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "speed")]
    fn connect_speed_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_speed_trampoline<P: IsA<Progress>, F: Fn(&P) + 'static>(this: *mut ffi::PkProgress, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Progress::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::speed\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_speed_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "status")]
    fn connect_status_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_status_trampoline<P: IsA<Progress>, F: Fn(&P) + 'static>(this: *mut ffi::PkProgress, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Progress::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::status\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_status_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_8_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_8_8")))]
    #[doc(alias = "transaction-flags")]
    fn connect_transaction_flags_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_transaction_flags_trampoline<P: IsA<Progress>, F: Fn(&P) + 'static>(this: *mut ffi::PkProgress, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Progress::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::transaction-flags\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_transaction_flags_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "transaction-id")]
    fn connect_transaction_id_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_transaction_id_trampoline<P: IsA<Progress>, F: Fn(&P) + 'static>(this: *mut ffi::PkProgress, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Progress::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::transaction-id\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_transaction_id_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "uid")]
    fn connect_uid_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_uid_trampoline<P: IsA<Progress>, F: Fn(&P) + 'static>(this: *mut ffi::PkProgress, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Progress::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::uid\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_uid_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl<O: IsA<Progress>> ProgressExt for O {}
