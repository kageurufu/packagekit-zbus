// Generated by gir (https://github.com/gtk-rs/gir @ 1c7a6b57a5fc)
// from gir-files (https://github.com/gtk-rs/gir-files.git @ 21b29d0e0c1a)
// from packagekit-gir-files
// DO NOT EDIT

#[cfg(feature = "v0_5_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
use crate::{Category,Details,DistroUpgrade,Error,EulaRequired,ExitEnum,Files,MediaChangeRequired,Package,PackageSack,RepoDetail,RepoSignatureRequired,RequireRestart,RestartEnum,RoleEnum,TransactionPast,UpdateDetail};
#[cfg(feature = "v0_5_3")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
use crate::{Progress};
#[cfg(feature = "v0_8_1")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_8_1")))]
use crate::{Bitfield};
use glib::{prelude::*};
#[cfg(feature = "v0_5_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
use glib::{signal::{connect_raw, SignalHandlerId},translate::*};
#[cfg(feature = "v0_5_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
use std::{boxed::Box as Box_};

glib::wrapper! {
    #[doc(alias = "PkResults")]
    pub struct Results(Object<ffi::PkResults, ffi::PkResultsClass>);

    match fn {
        type_ => || ffi::pk_results_get_type(),
    }
}

impl Results {
        pub const NONE: Option<&'static Results> = None;
    

    ///
    /// # Returns
    ///
    /// a new [`Results`][crate::Results] object.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_new")]
    pub fn new() -> Results {
        unsafe {
            from_glib_full(ffi::pk_results_new())
        }
    }
}

#[cfg(feature = "v0_5_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
impl Default for Results {
                     fn default() -> Self {
                         Self::new()
                     }
                 }

mod sealed {
    pub trait Sealed {}
    impl<T: super::IsA<super::Results>> Sealed for T {}
}

/// Trait containing all [`struct@Results`] methods.
///
/// # Implementors
///
/// [`Results`][struct@crate::Results]
pub trait ResultsExt: IsA<Results> + sealed::Sealed + 'static {
    /// Adds a category item to the results set.
    /// ## `item`
    /// the object to add to the array
    ///
    /// # Returns
    ///
    /// [`true`] if the value was set
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_add_category")]
    fn add_category(&self, item: &impl IsA<Category>) -> bool {
        unsafe {
            from_glib(ffi::pk_results_add_category(self.as_ref().to_glib_none().0, item.as_ref().to_glib_none().0))
        }
    }

    /// Adds some package details to the results set.
    /// ## `item`
    /// the object to add to the array
    ///
    /// # Returns
    ///
    /// [`true`] if the value was set
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_add_details")]
    fn add_details(&self, item: &impl IsA<Details>) -> bool {
        unsafe {
            from_glib(ffi::pk_results_add_details(self.as_ref().to_glib_none().0, item.as_ref().to_glib_none().0))
        }
    }

    /// Adds a distribution upgrade item to the results set.
    /// ## `item`
    /// the object to add to the array
    ///
    /// # Returns
    ///
    /// [`true`] if the value was set
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_add_distro_upgrade")]
    fn add_distro_upgrade(&self, item: &impl IsA<DistroUpgrade>) -> bool {
        unsafe {
            from_glib(ffi::pk_results_add_distro_upgrade(self.as_ref().to_glib_none().0, item.as_ref().to_glib_none().0))
        }
    }

    /// Adds some EULA details to the results set.
    /// ## `item`
    /// the object to add to the array
    ///
    /// # Returns
    ///
    /// [`true`] if the value was set
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_add_eula_required")]
    fn add_eula_required(&self, item: &impl IsA<EulaRequired>) -> bool {
        unsafe {
            from_glib(ffi::pk_results_add_eula_required(self.as_ref().to_glib_none().0, item.as_ref().to_glib_none().0))
        }
    }

    /// Adds some files details to the results set.
    /// ## `item`
    /// the object to add to the array
    ///
    /// # Returns
    ///
    /// [`true`] if the value was set
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_add_files")]
    fn add_files(&self, item: &impl IsA<Files>) -> bool {
        unsafe {
            from_glib(ffi::pk_results_add_files(self.as_ref().to_glib_none().0, item.as_ref().to_glib_none().0))
        }
    }

    /// Adds some media change details to the results set.
    /// ## `item`
    /// the object to add to the array
    ///
    /// # Returns
    ///
    /// [`true`] if the value was set
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_add_media_change_required")]
    fn add_media_change_required(&self, item: &impl IsA<MediaChangeRequired>) -> bool {
        unsafe {
            from_glib(ffi::pk_results_add_media_change_required(self.as_ref().to_glib_none().0, item.as_ref().to_glib_none().0))
        }
    }

    /// Adds a package to the results set.
    /// ## `item`
    /// the object to add to the array
    ///
    /// # Returns
    ///
    /// [`true`] if the value was set
    #[cfg(feature = "v0_5_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
    #[doc(alias = "pk_results_add_package")]
    fn add_package(&self, item: &impl IsA<Package>) -> bool {
        unsafe {
            from_glib(ffi::pk_results_add_package(self.as_ref().to_glib_none().0, item.as_ref().to_glib_none().0))
        }
    }

    /// Adds some repository details to the results set.
    /// ## `item`
    /// the object to add to the array
    ///
    /// # Returns
    ///
    /// [`true`] if the value was set
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_add_repo_detail")]
    fn add_repo_detail(&self, item: &impl IsA<RepoDetail>) -> bool {
        unsafe {
            from_glib(ffi::pk_results_add_repo_detail(self.as_ref().to_glib_none().0, item.as_ref().to_glib_none().0))
        }
    }

    /// Adds some repository signature details to the results set.
    /// ## `item`
    /// the object to add to the array
    ///
    /// # Returns
    ///
    /// [`true`] if the value was set
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_add_repo_signature_required")]
    fn add_repo_signature_required(&self, item: &impl IsA<RepoSignatureRequired>) -> bool {
        unsafe {
            from_glib(ffi::pk_results_add_repo_signature_required(self.as_ref().to_glib_none().0, item.as_ref().to_glib_none().0))
        }
    }

    /// Adds a require restart item to the results set.
    /// ## `item`
    /// the object to add to the array
    ///
    /// # Returns
    ///
    /// [`true`] if the value was set
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_add_require_restart")]
    fn add_require_restart(&self, item: &impl IsA<RequireRestart>) -> bool {
        unsafe {
            from_glib(ffi::pk_results_add_require_restart(self.as_ref().to_glib_none().0, item.as_ref().to_glib_none().0))
        }
    }

    /// Adds a transaction item to the results set.
    /// ## `item`
    /// the object to add to the array
    ///
    /// # Returns
    ///
    /// [`true`] if the value was set
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_add_transaction")]
    fn add_transaction(&self, item: &impl IsA<TransactionPast>) -> bool {
        unsafe {
            from_glib(ffi::pk_results_add_transaction(self.as_ref().to_glib_none().0, item.as_ref().to_glib_none().0))
        }
    }

    /// Adds some update details to the results set.
    /// ## `item`
    /// the object to add to the array
    ///
    /// # Returns
    ///
    /// [`true`] if the value was set
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_add_update_detail")]
    fn add_update_detail(&self, item: &impl IsA<UpdateDetail>) -> bool {
        unsafe {
            from_glib(ffi::pk_results_add_update_detail(self.as_ref().to_glib_none().0, item.as_ref().to_glib_none().0))
        }
    }

    /// Gets the categories from the transaction.
    ///
    /// # Returns
    ///
    /// A `GPtrArray` array of [`Category`][crate::Category]'s, free with `g_ptr_array_unref()`.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_get_category_array")]
    #[doc(alias = "get_category_array")]
    fn category_array(&self) -> Vec<Category> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::pk_results_get_category_array(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the package details from the transaction.
    ///
    /// # Returns
    ///
    /// A `GPtrArray` array of [`Details`][crate::Details]'s, free with `g_ptr_array_unref()`.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_get_details_array")]
    #[doc(alias = "get_details_array")]
    fn details_array(&self) -> Vec<Details> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::pk_results_get_details_array(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the distribution upgrades from the transaction.
    ///
    /// # Returns
    ///
    /// A `GPtrArray` array of [`DistroUpgrade`][crate::DistroUpgrade]'s, free with `g_ptr_array_unref()`.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_get_distro_upgrade_array")]
    #[doc(alias = "get_distro_upgrade_array")]
    fn distro_upgrade_array(&self) -> Vec<DistroUpgrade> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::pk_results_get_distro_upgrade_array(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the last error code from the transaction.
    ///
    /// # Returns
    ///
    /// A [`Error`][crate::Error], or [`None`], free with `g_object_unref()`
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_get_error_code")]
    #[doc(alias = "get_error_code")]
    fn error_code(&self) -> Option<Error> {
        unsafe {
            from_glib_full(ffi::pk_results_get_error_code(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the eulas required from the transaction.
    ///
    /// # Returns
    ///
    /// A `GPtrArray` array of [`EulaRequired`][crate::EulaRequired]'s, free with `g_ptr_array_unref()`.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_get_eula_required_array")]
    #[doc(alias = "get_eula_required_array")]
    fn eula_required_array(&self) -> Vec<EulaRequired> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::pk_results_get_eula_required_array(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the exit enum. You probably don't want to be using this function, and
    /// instead using the much more useful [`error_code()`][Self::error_code()] function.
    ///
    /// # Returns
    ///
    /// The [`ExitEnum`][crate::ExitEnum] or [`ExitEnum::Unknown`][crate::ExitEnum::Unknown] for error or if it was not set
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_get_exit_code")]
    #[doc(alias = "get_exit_code")]
    fn exit_code(&self) -> ExitEnum {
        unsafe {
            from_glib(ffi::pk_results_get_exit_code(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the files from the transaction.
    ///
    /// # Returns
    ///
    /// A `GPtrArray` array of [`Files`][crate::Files]'s, free with `g_ptr_array_unref()`.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_get_files_array")]
    #[doc(alias = "get_files_array")]
    fn files_array(&self) -> Vec<Files> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::pk_results_get_files_array(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the media changes required from the transaction.
    ///
    /// # Returns
    ///
    /// A `GPtrArray` array of [`MediaChangeRequired`][crate::MediaChangeRequired]'s, free with `g_ptr_array_unref()`.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_get_media_change_required_array")]
    #[doc(alias = "get_media_change_required_array")]
    fn media_change_required_array(&self) -> Vec<MediaChangeRequired> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::pk_results_get_media_change_required_array(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the packages from the transaction.
    ///
    /// # Returns
    ///
    /// A `GPtrArray` array of [`Package`][crate::Package]'s, free with `g_ptr_array_unref()`.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_get_package_array")]
    #[doc(alias = "get_package_array")]
    fn package_array(&self) -> Vec<Package> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::pk_results_get_package_array(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets a package sack from the transaction.
    ///
    /// # Returns
    ///
    /// A [`PackageSack`][crate::PackageSack] of data, `g_object_unref()` to free.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_get_package_sack")]
    #[doc(alias = "get_package_sack")]
    fn package_sack(&self) -> Option<PackageSack> {
        unsafe {
            from_glib_full(ffi::pk_results_get_package_sack(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the repository details from the transaction.
    ///
    /// # Returns
    ///
    /// A `GPtrArray` array of [`RepoDetail`][crate::RepoDetail]'s, free with `g_ptr_array_unref()`.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_get_repo_detail_array")]
    #[doc(alias = "get_repo_detail_array")]
    fn repo_detail_array(&self) -> Vec<RepoDetail> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::pk_results_get_repo_detail_array(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the repository signatures required from the transaction.
    ///
    /// # Returns
    ///
    /// A `GPtrArray` array of [`RepoSignatureRequired`][crate::RepoSignatureRequired]'s, free with `g_ptr_array_unref()`.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_get_repo_signature_required_array")]
    #[doc(alias = "get_repo_signature_required_array")]
    fn repo_signature_required_array(&self) -> Vec<RepoSignatureRequired> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::pk_results_get_repo_signature_required_array(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the require restarts from the transaction.
    ///
    /// # Returns
    ///
    /// A `GPtrArray` array of [`RequireRestart`][crate::RequireRestart]'s, free with `g_ptr_array_unref()`.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_get_require_restart_array")]
    #[doc(alias = "get_require_restart_array")]
    fn require_restart_array(&self) -> Vec<RequireRestart> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::pk_results_get_require_restart_array(self.as_ref().to_glib_none().0))
        }
    }

    /// This method returns the 'worst' restart of all the transactions.
    /// It is needed as multiple sub-transactions may emit require-restart with
    /// different values, and we always want to get the most invasive of all.
    ///
    /// For instance, if a transaction emits RequireRestart(system) and then
    /// RequireRestart(session) then pk_client_get_require_restart will return
    /// system as a session restart is implied with a system restart.
    ///
    /// # Returns
    ///
    /// a [`RestartEnum`][crate::RestartEnum] value, e.g. PK_RESTART_ENUM_SYSTEM
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_get_require_restart_worst")]
    #[doc(alias = "get_require_restart_worst")]
    fn require_restart_worst(&self) -> RestartEnum {
        unsafe {
            from_glib(ffi::pk_results_get_require_restart_worst(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the role that produced these results.
    ///
    /// # Returns
    ///
    /// The [`RoleEnum`][crate::RoleEnum] or [`RoleEnum::Unknown`][crate::RoleEnum::Unknown] if not set
    #[cfg(feature = "v0_7_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_7_5")))]
    #[doc(alias = "pk_results_get_role")]
    #[doc(alias = "get_role")]
    fn role(&self) -> RoleEnum {
        unsafe {
            from_glib(ffi::pk_results_get_role(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the transactions from the transaction.
    ///
    /// # Returns
    ///
    /// A `GPtrArray` array of [`TransactionPast`][crate::TransactionPast]'s, free with `g_ptr_array_unref()`.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_get_transaction_array")]
    #[doc(alias = "get_transaction_array")]
    fn transaction_array(&self) -> Vec<TransactionPast> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::pk_results_get_transaction_array(self.as_ref().to_glib_none().0))
        }
    }

    /// Gets the transaction flag for these results.
    ///
    /// # Returns
    ///
    /// a `PkBitfield` containing [`TransactionFlagEnum`][crate::TransactionFlagEnum] 0 if not set
    #[cfg(feature = "v0_8_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_8_1")))]
    #[doc(alias = "pk_results_get_transaction_flags")]
    #[doc(alias = "get_transaction_flags")]
    fn transaction_flags(&self) -> Bitfield {
        unsafe {
            ffi::pk_results_get_transaction_flags(self.as_ref().to_glib_none().0)
        }
    }

    /// Gets the update details from the transaction.
    ///
    /// # Returns
    ///
    /// A `GPtrArray` array of [`UpdateDetail`][crate::UpdateDetail]'s, free with `g_ptr_array_unref()`.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_get_update_detail_array")]
    #[doc(alias = "get_update_detail_array")]
    fn update_detail_array(&self) -> Vec<UpdateDetail> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::pk_results_get_update_detail_array(self.as_ref().to_glib_none().0))
        }
    }

    /// Adds some error details to the results set.
    /// ## `item`
    /// the object to add to the array
    ///
    /// # Returns
    ///
    /// [`true`] if the value was set
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_set_error_code")]
    fn set_error_code(&self, item: &impl IsA<Error>) -> bool {
        unsafe {
            from_glib(ffi::pk_results_set_error_code(self.as_ref().to_glib_none().0, item.as_ref().to_glib_none().0))
        }
    }

    /// Sets the results object to have the given exit code.
    /// ## `exit_enum`
    /// the exit code
    ///
    /// # Returns
    ///
    /// [`true`] if the value was set
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_results_set_exit_code")]
    fn set_exit_code(&self, exit_enum: ExitEnum) -> bool {
        unsafe {
            from_glib(ffi::pk_results_set_exit_code(self.as_ref().to_glib_none().0, exit_enum.into_glib()))
        }
    }

    /// Sets the results object to have the given role enum.
    /// ## `role`
    /// the role enum
    ///
    /// # Returns
    ///
    /// [`true`] if the value was set
    #[cfg(feature = "v1_1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_1_8")))]
    #[doc(alias = "pk_results_set_role")]
    fn set_role(&self, role: RoleEnum) -> bool {
        unsafe {
            from_glib(ffi::pk_results_set_role(self.as_ref().to_glib_none().0, role.into_glib()))
        }
    }

    #[cfg(feature = "v0_5_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
    fn inputs(&self) -> u32 {
        ObjectExt::property(self.as_ref(), "inputs")
    }

    #[cfg(feature = "v0_5_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
    fn set_inputs(&self, inputs: u32) {
        ObjectExt::set_property(self.as_ref(),"inputs", inputs)
    }

    #[cfg(feature = "v0_5_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
    fn progress(&self) -> Option<Progress> {
        ObjectExt::property(self.as_ref(), "progress")
    }

    #[cfg(feature = "v0_5_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
    fn set_progress<P: IsA<Progress>>(&self, progress: Option<&P>) {
        ObjectExt::set_property(self.as_ref(),"progress", progress)
    }

    /// The [`RoleEnum`][crate::RoleEnum] or [`RoleEnum::Unknown`][crate::RoleEnum::Unknown] if not set
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    fn get_property_role(&self) -> RoleEnum {
        ObjectExt::property(self.as_ref(), "role")
    }

    /// The [`RoleEnum`][crate::RoleEnum] or [`RoleEnum::Unknown`][crate::RoleEnum::Unknown] if not set
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    fn set_property_role(&self, role: RoleEnum) {
        ObjectExt::set_property(self.as_ref(),"role", role)
    }

    /// A `PkBitfield` containing [`TransactionFlagEnum`][crate::TransactionFlagEnum] for this result.
    #[cfg(feature = "v0_8_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_8_1")))]
    #[doc(alias = "transaction-flags")]
    fn set_transaction_flags(&self, transaction_flags: u64) {
        ObjectExt::set_property(self.as_ref(),"transaction-flags", transaction_flags)
    }

    #[cfg(feature = "v0_5_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
    #[doc(alias = "inputs")]
    fn connect_inputs_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_inputs_trampoline<P: IsA<Results>, F: Fn(&P) + 'static>(this: *mut ffi::PkResults, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Results::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::inputs\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_inputs_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
    #[doc(alias = "progress")]
    fn connect_progress_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_progress_trampoline<P: IsA<Results>, F: Fn(&P) + 'static>(this: *mut ffi::PkResults, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Results::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::progress\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_progress_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "role")]
    fn connect_role_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_role_trampoline<P: IsA<Results>, F: Fn(&P) + 'static>(this: *mut ffi::PkResults, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Results::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::role\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_role_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_8_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_8_1")))]
    #[doc(alias = "transaction-flags")]
    fn connect_transaction_flags_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_transaction_flags_trampoline<P: IsA<Results>, F: Fn(&P) + 'static>(this: *mut ffi::PkResults, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Results::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::transaction-flags\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_transaction_flags_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl<O: IsA<Results>> ResultsExt for O {}
