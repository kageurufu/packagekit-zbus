// Generated by gir (https://github.com/gtk-rs/gir @ 1c7a6b57a5fc)
// from gir-files (https://github.com/gtk-rs/gir-files.git @ 21b29d0e0c1a)
// from packagekit-gir-files
// DO NOT EDIT

use glib::{prelude::*};
#[cfg(feature = "v0_6_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_6_10")))]
use glib::{translate::*};

glib::wrapper! {
    #[doc(alias = "PkClientHelper")]
    pub struct ClientHelper(Object<ffi::PkClientHelper, ffi::PkClientHelperClass>);

    match fn {
        type_ => || ffi::pk_client_helper_get_type(),
    }
}

impl ClientHelper {
        pub const NONE: Option<&'static ClientHelper> = None;
    

    ///
    /// # Returns
    ///
    /// a new [`ClientHelper`][crate::ClientHelper] object.
    #[cfg(feature = "v0_6_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_6_10")))]
    #[doc(alias = "pk_client_helper_new")]
    pub fn new() -> ClientHelper {
        unsafe {
            from_glib_full(ffi::pk_client_helper_new())
        }
    }
}

#[cfg(feature = "v0_6_10")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_6_10")))]
impl Default for ClientHelper {
                     fn default() -> Self {
                         Self::new()
                     }
                 }

mod sealed {
    pub trait Sealed {}
    impl<T: super::IsA<super::ClientHelper>> Sealed for T {}
}

/// Trait containing all [`struct@ClientHelper`] methods.
///
/// # Implementors
///
/// [`ClientHelper`][struct@crate::ClientHelper]
pub trait ClientHelperExt: IsA<ClientHelper> + sealed::Sealed + 'static {
    ///
    /// # Returns
    ///
    /// TRUE if there is an accepted connection, FALSE
    ///  otherwise.
    #[cfg(feature = "v1_1_13")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_1_13")))]
    #[doc(alias = "pk_client_helper_is_active")]
    fn is_active(&self) -> bool {
        unsafe {
            from_glib(ffi::pk_client_helper_is_active(self.as_ref().to_glib_none().0))
        }
    }

    /// Starts the helper process, by running the helper process and setting
    /// up the socket for use.
    /// ## `socket_filename`
    /// a socket filename that does not already exist
    /// ## `argv`
    /// the executable, along with any arguments
    /// ## `envp`
    /// the environment
    ///
    /// # Returns
    ///
    /// [`true`] for success
    #[cfg(feature = "v0_6_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_6_10")))]
    #[doc(alias = "pk_client_helper_start")]
    fn start(&self, socket_filename: &str, argv: &str, envp: &str) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::pk_client_helper_start(self.as_ref().to_glib_none().0, socket_filename.to_glib_none().0, argv.to_glib_none().0, envp.to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    /// Starts the helper process, by running the helper process and setting
    /// up the socket for use.
    /// ## `socket`
    /// the (bound and listening) [`gio::Socket`][crate::gio::Socket] instance to use
    /// ## `argv`
    /// the executable, along with any arguments
    /// ## `envp`
    /// the environment
    ///
    /// # Returns
    ///
    /// [`true`] for success
    #[cfg(feature = "v1_1_13")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v1_1_13")))]
    #[doc(alias = "pk_client_helper_start_with_socket")]
    fn start_with_socket(&self, socket: &impl IsA<gio::Socket>, argv: &str, envp: &str) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::pk_client_helper_start_with_socket(self.as_ref().to_glib_none().0, socket.as_ref().to_glib_none().0, argv.to_glib_none().0, envp.to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    /// Stops the helper process, by killing the helper process and deleting
    /// the socket.
    ///
    /// # Returns
    ///
    /// [`true`] for success
    #[cfg(feature = "v0_6_10")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_6_10")))]
    #[doc(alias = "pk_client_helper_stop")]
    fn stop(&self) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::pk_client_helper_stop(self.as_ref().to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }
}

impl<O: IsA<ClientHelper>> ClientHelperExt for O {}
