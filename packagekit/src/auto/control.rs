// Generated by gir (https://github.com/gtk-rs/gir @ 1c7a6b57a5fc)
// from gir-files (https://github.com/gtk-rs/gir-files.git @ 21b29d0e0c1a)
// from packagekit-gir-files
// DO NOT EDIT

#[cfg(feature = "v0_5_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
use crate::{AuthorizeEnum,RoleEnum};
#[cfg(feature = "v0_5_3")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
use crate::{NetworkEnum};
use glib::{prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_};
#[cfg(feature = "v0_5_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
use std::{pin::Pin};

glib::wrapper! {
    #[doc(alias = "PkControl")]
    pub struct Control(Object<ffi::PkControl, ffi::PkControlClass>);

    match fn {
        type_ => || ffi::pk_control_get_type(),
    }
}

impl Control {
        pub const NONE: Option<&'static Control> = None;
    

    ///
    /// # Returns
    ///
    /// a new [`Control`][crate::Control] object.
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_control_new")]
    pub fn new() -> Control {
        unsafe {
            from_glib_full(ffi::pk_control_new())
        }
    }
}

#[cfg(feature = "v0_5_2")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
impl Default for Control {
                     fn default() -> Self {
                         Self::new()
                     }
                 }

mod sealed {
    pub trait Sealed {}
    impl<T: super::IsA<super::Control>> Sealed for T {}
}

/// Trait containing all [`struct@Control`] methods.
///
/// # Implementors
///
/// [`Control`][struct@crate::Control]
pub trait ControlExt: IsA<Control> + sealed::Sealed + 'static {
    /// We may want to know before we run a method if we are going to be denied,
    /// accepted or challenged for authentication.
    /// ## `action_id`
    /// The action ID, for instance "org.freedesktop.PackageKit.install-untrusted"
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable] or [`None`]
    /// ## `callback`
    /// the function to run on completion
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_control_can_authorize_async")]
    fn can_authorize_async<P: FnOnce(Result<AuthorizeEnum, glib::Error>) + 'static>(&self, action_id: &str, cancellable: Option<&impl IsA<gio::Cancellable>>, callback: P) {
        
                let main_context = glib::MainContext::ref_thread_default();
                let is_main_context_owner = main_context.is_owner();
                let has_acquired_main_context = (!is_main_context_owner)
                    .then(|| main_context.acquire().ok())
                    .flatten();
                assert!(
                    is_main_context_owner || has_acquired_main_context.is_some(),
                    "Async operations only allowed if the thread is owning the MainContext"
                );
        
        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn can_authorize_async_trampoline<P: FnOnce(Result<AuthorizeEnum, glib::Error>) + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) {
            let mut error = std::ptr::null_mut();
            let ret = ffi::pk_control_can_authorize_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() { Ok(from_glib(ret)) } else { Err(from_glib_full(error)) };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = can_authorize_async_trampoline::<P>;
        unsafe {
            ffi::pk_control_can_authorize_async(self.as_ref().to_glib_none().0, action_id.to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    fn can_authorize_future(&self, action_id: &str) -> Pin<Box_<dyn std::future::Future<Output = Result<AuthorizeEnum, glib::Error>> + 'static>> {

        let action_id = String::from(action_id);
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.can_authorize_async(
                &action_id,
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    /// Gets the debugging state from the daemon.
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable] or [`None`]
    /// ## `callback`
    /// the function to run on completion
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_control_get_daemon_state_async")]
    #[doc(alias = "get_daemon_state_async")]
    fn daemon_state_async<P: FnOnce(Result<glib::GString, glib::Error>) + 'static>(&self, cancellable: Option<&impl IsA<gio::Cancellable>>, callback: P) {
        
                let main_context = glib::MainContext::ref_thread_default();
                let is_main_context_owner = main_context.is_owner();
                let has_acquired_main_context = (!is_main_context_owner)
                    .then(|| main_context.acquire().ok())
                    .flatten();
                assert!(
                    is_main_context_owner || has_acquired_main_context.is_some(),
                    "Async operations only allowed if the thread is owning the MainContext"
                );
        
        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn daemon_state_async_trampoline<P: FnOnce(Result<glib::GString, glib::Error>) + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) {
            let mut error = std::ptr::null_mut();
            let ret = ffi::pk_control_get_daemon_state_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = daemon_state_async_trampoline::<P>;
        unsafe {
            ffi::pk_control_get_daemon_state_async(self.as_ref().to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    fn daemon_state_future(&self) -> Pin<Box_<dyn std::future::Future<Output = Result<glib::GString, glib::Error>> + 'static>> {

        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.daemon_state_async(
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    /// Gets the properties the daemon supports.
    /// Warning: this function is synchronous, and may block. Do not use it in GUI
    /// applications.
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable] or [`None`]
    ///
    /// # Returns
    ///
    /// [`true`] if the properties were set correctly
    #[cfg(feature = "v0_5_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
    #[doc(alias = "pk_control_get_properties")]
    #[doc(alias = "get_properties")]
    fn properties(&self, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::pk_control_get_properties(self.as_ref().to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    /// Gets global properties from the daemon.
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable] or [`None`]
    /// ## `callback`
    /// the function to run on completion
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_control_get_properties_async")]
    #[doc(alias = "get_properties_async")]
    fn properties_async<P: FnOnce(Result<(), glib::Error>) + 'static>(&self, cancellable: Option<&impl IsA<gio::Cancellable>>, callback: P) {
        
                let main_context = glib::MainContext::ref_thread_default();
                let is_main_context_owner = main_context.is_owner();
                let has_acquired_main_context = (!is_main_context_owner)
                    .then(|| main_context.acquire().ok())
                    .flatten();
                assert!(
                    is_main_context_owner || has_acquired_main_context.is_some(),
                    "Async operations only allowed if the thread is owning the MainContext"
                );
        
        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn properties_async_trampoline<P: FnOnce(Result<(), glib::Error>) + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) {
            let mut error = std::ptr::null_mut();
            let _ = ffi::pk_control_get_properties_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = properties_async_trampoline::<P>;
        unsafe {
            ffi::pk_control_get_properties_async(self.as_ref().to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    fn properties_future(&self) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {

        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.properties_async(
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    /// Gets a transacton ID from the daemon.
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable] or [`None`]
    /// ## `callback`
    /// the function to run on completion
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_control_get_tid_async")]
    #[doc(alias = "get_tid_async")]
    fn tid_async<P: FnOnce(Result<glib::GString, glib::Error>) + 'static>(&self, cancellable: Option<&impl IsA<gio::Cancellable>>, callback: P) {
        
                let main_context = glib::MainContext::ref_thread_default();
                let is_main_context_owner = main_context.is_owner();
                let has_acquired_main_context = (!is_main_context_owner)
                    .then(|| main_context.acquire().ok())
                    .flatten();
                assert!(
                    is_main_context_owner || has_acquired_main_context.is_some(),
                    "Async operations only allowed if the thread is owning the MainContext"
                );
        
        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn tid_async_trampoline<P: FnOnce(Result<glib::GString, glib::Error>) + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) {
            let mut error = std::ptr::null_mut();
            let ret = ffi::pk_control_get_tid_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = tid_async_trampoline::<P>;
        unsafe {
            ffi::pk_control_get_tid_async(self.as_ref().to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    fn tid_future(&self) -> Pin<Box_<dyn std::future::Future<Output = Result<glib::GString, glib::Error>> + 'static>> {

        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.tid_async(
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    /// We may want to know how long it has been since we refreshed the cache or
    /// retrieved the update list.
    /// ## `role`
    /// the role enum, e.g. [`RoleEnum::GetUpdates`][crate::RoleEnum::GetUpdates]
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable] or [`None`]
    /// ## `callback`
    /// the function to run on completion
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_control_get_time_since_action_async")]
    #[doc(alias = "get_time_since_action_async")]
    fn time_since_action_async<P: FnOnce(Result<(), glib::Error>) + 'static>(&self, role: RoleEnum, cancellable: Option<&impl IsA<gio::Cancellable>>, callback: P) {
        
                let main_context = glib::MainContext::ref_thread_default();
                let is_main_context_owner = main_context.is_owner();
                let has_acquired_main_context = (!is_main_context_owner)
                    .then(|| main_context.acquire().ok())
                    .flatten();
                assert!(
                    is_main_context_owner || has_acquired_main_context.is_some(),
                    "Async operations only allowed if the thread is owning the MainContext"
                );
        
        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn time_since_action_async_trampoline<P: FnOnce(Result<(), glib::Error>) + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) {
            let mut error = std::ptr::null_mut();
            let _ = ffi::pk_control_get_time_since_action_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = time_since_action_async_trampoline::<P>;
        unsafe {
            ffi::pk_control_get_time_since_action_async(self.as_ref().to_glib_none().0, role.into_glib(), cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    fn time_since_action_future(&self, role: RoleEnum) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {

        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.time_since_action_async(
                role,
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    /// Gets the transaction list in progress.
    /// Warning: this function is synchronous, and may block. Do not use it in GUI
    /// applications.
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable] or [`None`]
    ///
    /// # Returns
    ///
    /// The list of transaction id's, or [`None`], free with `g_strfreev()`
    #[cfg(feature = "v0_5_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
    #[doc(alias = "pk_control_get_transaction_list")]
    #[doc(alias = "get_transaction_list")]
    fn transaction_list(&self, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<Vec<glib::GString>, glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let ret = ffi::pk_control_get_transaction_list(self.as_ref().to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
            if error.is_null() { Ok(FromGlibPtrContainer::from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }

    /// Gets the transactions currently running in the daemon.
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable] or [`None`]
    /// ## `callback`
    /// the function to run on completion
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_control_get_transaction_list_async")]
    #[doc(alias = "get_transaction_list_async")]
    fn transaction_list_async<P: FnOnce(Result<Vec<glib::GString>, glib::Error>) + 'static>(&self, cancellable: Option<&impl IsA<gio::Cancellable>>, callback: P) {
        
                let main_context = glib::MainContext::ref_thread_default();
                let is_main_context_owner = main_context.is_owner();
                let has_acquired_main_context = (!is_main_context_owner)
                    .then(|| main_context.acquire().ok())
                    .flatten();
                assert!(
                    is_main_context_owner || has_acquired_main_context.is_some(),
                    "Async operations only allowed if the thread is owning the MainContext"
                );
        
        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn transaction_list_async_trampoline<P: FnOnce(Result<Vec<glib::GString>, glib::Error>) + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) {
            let mut error = std::ptr::null_mut();
            let ret = ffi::pk_control_get_transaction_list_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() { Ok(FromGlibPtrContainer::from_glib_full(ret)) } else { Err(from_glib_full(error)) };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = transaction_list_async_trampoline::<P>;
        unsafe {
            ffi::pk_control_get_transaction_list_async(self.as_ref().to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    fn transaction_list_future(&self) -> Pin<Box_<dyn std::future::Future<Output = Result<Vec<glib::GString>, glib::Error>> + 'static>> {

        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.transaction_list_async(
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    /// Sets the network proxy to use in the daemon.
    /// Warning: this function is synchronous, and may block. Do not use it in GUI
    /// applications.
    /// ## `proxy_http`
    /// the HTTP proxy server
    /// ## `proxy_ftp`
    /// the FTP proxy server
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable] or [`None`]
    ///
    /// # Returns
    ///
    /// [`true`] if the proxy was set correctly
    ///
    /// NOTE: This is just provided for backwards compatibility.
    /// Clients should really be using [`set_proxy2()`][Self::set_proxy2()].
    #[cfg(feature = "v0_6_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_6_3")))]
    #[doc(alias = "pk_control_set_proxy")]
    fn set_proxy(&self, proxy_http: &str, proxy_ftp: &str, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::pk_control_set_proxy(self.as_ref().to_glib_none().0, proxy_http.to_glib_none().0, proxy_ftp.to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    /// Sets the network proxy to use in the daemon.
    /// Warning: this function is synchronous, and may block. Do not use it in GUI
    /// applications.
    /// ## `proxy_http`
    /// the HTTP proxy server
    /// ## `proxy_https`
    /// the HTTPS proxy server
    /// ## `proxy_ftp`
    /// the FTP proxy server
    /// ## `proxy_socks`
    /// the SOCKS proxy server
    /// ## `no_proxy`
    /// the list of download IPs that shouldn't go through the proxy
    /// ## `pac`
    /// the PAC string
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable] or [`None`]
    ///
    /// # Returns
    ///
    /// [`true`] if the proxy was set correctly
    #[cfg(feature = "v0_6_13")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_6_13")))]
    #[doc(alias = "pk_control_set_proxy2")]
    fn set_proxy2(&self, proxy_http: &str, proxy_https: &str, proxy_ftp: &str, proxy_socks: &str, no_proxy: &str, pac: &str, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::pk_control_set_proxy2(self.as_ref().to_glib_none().0, proxy_http.to_glib_none().0, proxy_https.to_glib_none().0, proxy_ftp.to_glib_none().0, proxy_socks.to_glib_none().0, no_proxy.to_glib_none().0, pac.to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    //#[cfg(feature = "v0_6_13")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v0_6_13")))]
    //#[doc(alias = "pk_control_set_proxy2_async")]
    //fn set_proxy2_async<P: FnOnce(Result<(), glib::Error>) + 'static>(&self, proxy_http: &str, proxy_https: &str, proxy_ftp: &str, proxy_socks: &str, no_proxy: &str, pac: &str, cancellable: Option<&impl IsA<gio::Cancellable>>, callback: P) {
    //    unsafe { TODO: call ffi:pk_control_set_proxy2_async() }
    //}

    /// Set a proxy on the PK daemon
    ///
    /// NOTE: This is just provided for backwards compatibility.
    /// Clients should really be using `pk_control_set_proxy2_async()`.
    /// ## `proxy_http`
    /// a HTTP proxy string such as "username:password`server`:8080"
    /// ## `proxy_ftp`
    /// a FTP proxy string such as "server.lan:8080"
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable] or [`None`]
    /// ## `callback`
    /// the function to run on completion
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "pk_control_set_proxy_async")]
    fn set_proxy_async<P: FnOnce(Result<(), glib::Error>) + 'static>(&self, proxy_http: &str, proxy_ftp: &str, cancellable: Option<&impl IsA<gio::Cancellable>>, callback: P) {
        
                let main_context = glib::MainContext::ref_thread_default();
                let is_main_context_owner = main_context.is_owner();
                let has_acquired_main_context = (!is_main_context_owner)
                    .then(|| main_context.acquire().ok())
                    .flatten();
                assert!(
                    is_main_context_owner || has_acquired_main_context.is_some(),
                    "Async operations only allowed if the thread is owning the MainContext"
                );
        
        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn set_proxy_async_trampoline<P: FnOnce(Result<(), glib::Error>) + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) {
            let mut error = std::ptr::null_mut();
            let _ = ffi::pk_control_set_proxy_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = set_proxy_async_trampoline::<P>;
        unsafe {
            ffi::pk_control_set_proxy_async(self.as_ref().to_glib_none().0, proxy_http.to_glib_none().0, proxy_ftp.to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    fn set_proxy_future(&self, proxy_http: &str, proxy_ftp: &str) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {

        let proxy_http = String::from(proxy_http);
        let proxy_ftp = String::from(proxy_ftp);
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.set_proxy_async(
                &proxy_http,
                &proxy_ftp,
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    /// Suggests to the daemon that it should quit as soon as possible.
    /// Warning: this function is synchronous, and may block. Do not use it in GUI
    /// applications.
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable] or [`None`]
    ///
    /// # Returns
    ///
    /// [`true`] if the suggestion was sent
    #[cfg(feature = "v0_6_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_6_2")))]
    #[doc(alias = "pk_control_suggest_daemon_quit")]
    fn suggest_daemon_quit(&self, cancellable: Option<&impl IsA<gio::Cancellable>>) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::pk_control_suggest_daemon_quit(self.as_ref().to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, &mut error);
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) }
        }
    }

    /// Suggests to the daemon that it should quit as soon as possible.
    /// ## `cancellable`
    /// a [`gio::Cancellable`][crate::gio::Cancellable] or [`None`]
    /// ## `callback`
    /// the function to run on completion
    #[cfg(feature = "v0_6_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_6_2")))]
    #[doc(alias = "pk_control_suggest_daemon_quit_async")]
    fn suggest_daemon_quit_async<P: FnOnce(Result<(), glib::Error>) + 'static>(&self, cancellable: Option<&impl IsA<gio::Cancellable>>, callback: P) {
        
                let main_context = glib::MainContext::ref_thread_default();
                let is_main_context_owner = main_context.is_owner();
                let has_acquired_main_context = (!is_main_context_owner)
                    .then(|| main_context.acquire().ok())
                    .flatten();
                assert!(
                    is_main_context_owner || has_acquired_main_context.is_some(),
                    "Async operations only allowed if the thread is owning the MainContext"
                );
        
        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn suggest_daemon_quit_async_trampoline<P: FnOnce(Result<(), glib::Error>) + 'static>(_source_object: *mut glib::gobject_ffi::GObject, res: *mut gio::ffi::GAsyncResult, user_data: glib::ffi::gpointer) {
            let mut error = std::ptr::null_mut();
            let _ = ffi::pk_control_suggest_daemon_quit_finish(_source_object as *mut _, res, &mut error);
            let result = if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) };
            let callback: Box_<glib::thread_guard::ThreadGuard<P>> = Box_::from_raw(user_data as *mut _);
            let callback: P = callback.into_inner();
            callback(result);
        }
        let callback = suggest_daemon_quit_async_trampoline::<P>;
        unsafe {
            ffi::pk_control_suggest_daemon_quit_async(self.as_ref().to_glib_none().0, cancellable.map(|p| p.as_ref()).to_glib_none().0, Some(callback), Box_::into_raw(user_data) as *mut _);
        }
    }

    
    #[cfg(feature = "v0_6_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_6_2")))]
    fn suggest_daemon_quit_future(&self) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {

        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.suggest_daemon_quit_async(
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "backend-author")]
    fn backend_author(&self) -> Option<glib::GString> {
        ObjectExt::property(self.as_ref(), "backend-author")
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "backend-author")]
    fn set_backend_author(&self, backend_author: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"backend-author", backend_author)
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "backend-description")]
    fn backend_description(&self) -> Option<glib::GString> {
        ObjectExt::property(self.as_ref(), "backend-description")
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "backend-description")]
    fn set_backend_description(&self, backend_description: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"backend-description", backend_description)
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "backend-name")]
    fn backend_name(&self) -> Option<glib::GString> {
        ObjectExt::property(self.as_ref(), "backend-name")
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "backend-name")]
    fn set_backend_name(&self, backend_name: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"backend-name", backend_name)
    }

    #[cfg(feature = "v0_5_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
    fn is_connected(&self) -> bool {
        ObjectExt::property(self.as_ref(), "connected")
    }

    #[cfg(feature = "v0_5_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
    fn set_connected(&self, connected: bool) {
        ObjectExt::set_property(self.as_ref(),"connected", connected)
    }

    #[cfg(feature = "v0_5_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_5")))]
    #[doc(alias = "distro-id")]
    fn distro_id(&self) -> Option<glib::GString> {
        ObjectExt::property(self.as_ref(), "distro-id")
    }

    #[cfg(feature = "v0_5_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_5")))]
    #[doc(alias = "distro-id")]
    fn set_distro_id(&self, distro_id: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"distro-id", distro_id)
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    fn filters(&self) -> u64 {
        ObjectExt::property(self.as_ref(), "filters")
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    fn set_filters(&self, filters: u64) {
        ObjectExt::set_property(self.as_ref(),"filters", filters)
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    fn groups(&self) -> u64 {
        ObjectExt::property(self.as_ref(), "groups")
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    fn set_groups(&self, groups: u64) {
        ObjectExt::set_property(self.as_ref(),"groups", groups)
    }

    #[cfg(feature = "v0_5_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
    fn is_locked(&self) -> bool {
        ObjectExt::property(self.as_ref(), "locked")
    }

    #[cfg(feature = "v0_5_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
    fn set_locked(&self, locked: bool) {
        ObjectExt::set_property(self.as_ref(),"locked", locked)
    }

    #[cfg(feature = "v0_8_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_8_1")))]
    #[doc(alias = "mime-types")]
    fn mime_types(&self) -> Vec<glib::GString> {
        ObjectExt::property(self.as_ref(), "mime-types")
    }

    #[cfg(feature = "v0_8_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_8_1")))]
    #[doc(alias = "mime-types")]
    fn set_mime_types(&self, mime_types: &[&str]) {
        ObjectExt::set_property(self.as_ref(),"mime-types", mime_types)
    }

    #[cfg(feature = "v0_5_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
    #[doc(alias = "network-state")]
    fn network_state(&self) -> NetworkEnum {
        ObjectExt::property(self.as_ref(), "network-state")
    }

    #[cfg(feature = "v0_5_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
    #[doc(alias = "network-state")]
    fn set_network_state(&self, network_state: NetworkEnum) {
        ObjectExt::set_property(self.as_ref(),"network-state", network_state)
    }

    #[cfg(feature = "v0_8_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_8_8")))]
    fn provides(&self) -> u64 {
        ObjectExt::property(self.as_ref(), "provides")
    }

    #[cfg(feature = "v0_8_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_8_8")))]
    fn set_provides(&self, provides: u64) {
        ObjectExt::set_property(self.as_ref(),"provides", provides)
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    fn roles(&self) -> u64 {
        ObjectExt::property(self.as_ref(), "roles")
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    fn set_roles(&self, roles: u64) {
        ObjectExt::set_property(self.as_ref(),"roles", roles)
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "version-major")]
    fn version_major(&self) -> u32 {
        ObjectExt::property(self.as_ref(), "version-major")
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "version-micro")]
    fn version_micro(&self) -> u32 {
        ObjectExt::property(self.as_ref(), "version-micro")
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "version-minor")]
    fn version_minor(&self) -> u32 {
        ObjectExt::property(self.as_ref(), "version-minor")
    }

    /// The ::repo-list-changed signal is emitted when the repo list may have
    /// changed and the control program may have to update some UI.
    #[doc(alias = "repo-list-changed")]
    fn connect_repo_list_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn repo_list_changed_trampoline<P: IsA<Control>, F: Fn(&P) + 'static>(this: *mut ffi::PkControl, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Control::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"repo-list-changed\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(repo_list_changed_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    /// The ::restart_schedule signal is emitted when the packagekitd service
    /// has been restarted because it has been upgraded.
    /// Client programs should reload themselves when it is convenient to
    /// do so, as old client tools may not be compatable with the new daemon.
    #[doc(alias = "restart-schedule")]
    fn connect_restart_schedule<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn restart_schedule_trampoline<P: IsA<Control>, F: Fn(&P) + 'static>(this: *mut ffi::PkControl, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Control::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"restart-schedule\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(restart_schedule_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    //#[doc(alias = "transaction-list-changed")]
    //fn connect_transaction_list_changed<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Empty ctype transaction_ids: *.CArray TypeId { ns_id: 0, id: 28 }
    //}

    /// The ::updates-changed signal is emitted when the update list may have
    /// changed and the control program may have to update some UI.
    #[doc(alias = "updates-changed")]
    fn connect_updates_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn updates_changed_trampoline<P: IsA<Control>, F: Fn(&P) + 'static>(this: *mut ffi::PkControl, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Control::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"updates-changed\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(updates_changed_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "backend-author")]
    fn connect_backend_author_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_backend_author_trampoline<P: IsA<Control>, F: Fn(&P) + 'static>(this: *mut ffi::PkControl, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Control::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::backend-author\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_backend_author_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "backend-description")]
    fn connect_backend_description_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_backend_description_trampoline<P: IsA<Control>, F: Fn(&P) + 'static>(this: *mut ffi::PkControl, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Control::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::backend-description\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_backend_description_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "backend-name")]
    fn connect_backend_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_backend_name_trampoline<P: IsA<Control>, F: Fn(&P) + 'static>(this: *mut ffi::PkControl, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Control::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::backend-name\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_backend_name_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
    #[doc(alias = "connected")]
    fn connect_connected_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_connected_trampoline<P: IsA<Control>, F: Fn(&P) + 'static>(this: *mut ffi::PkControl, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Control::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::connected\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_connected_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_5")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_5")))]
    #[doc(alias = "distro-id")]
    fn connect_distro_id_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_distro_id_trampoline<P: IsA<Control>, F: Fn(&P) + 'static>(this: *mut ffi::PkControl, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Control::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::distro-id\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_distro_id_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "filters")]
    fn connect_filters_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_filters_trampoline<P: IsA<Control>, F: Fn(&P) + 'static>(this: *mut ffi::PkControl, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Control::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::filters\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_filters_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "groups")]
    fn connect_groups_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_groups_trampoline<P: IsA<Control>, F: Fn(&P) + 'static>(this: *mut ffi::PkControl, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Control::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::groups\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_groups_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
    #[doc(alias = "locked")]
    fn connect_locked_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_locked_trampoline<P: IsA<Control>, F: Fn(&P) + 'static>(this: *mut ffi::PkControl, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Control::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::locked\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_locked_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_8_1")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_8_1")))]
    #[doc(alias = "mime-types")]
    fn connect_mime_types_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_mime_types_trampoline<P: IsA<Control>, F: Fn(&P) + 'static>(this: *mut ffi::PkControl, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Control::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::mime-types\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_mime_types_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_3")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_3")))]
    #[doc(alias = "network-state")]
    fn connect_network_state_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_network_state_trampoline<P: IsA<Control>, F: Fn(&P) + 'static>(this: *mut ffi::PkControl, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Control::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::network-state\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_network_state_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_8_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_8_8")))]
    #[doc(alias = "provides")]
    fn connect_provides_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_provides_trampoline<P: IsA<Control>, F: Fn(&P) + 'static>(this: *mut ffi::PkControl, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Control::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::provides\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_provides_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "roles")]
    fn connect_roles_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_roles_trampoline<P: IsA<Control>, F: Fn(&P) + 'static>(this: *mut ffi::PkControl, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Control::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::roles\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_roles_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "version-major")]
    fn connect_version_major_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_version_major_trampoline<P: IsA<Control>, F: Fn(&P) + 'static>(this: *mut ffi::PkControl, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Control::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::version-major\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_version_major_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "version-micro")]
    fn connect_version_micro_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_version_micro_trampoline<P: IsA<Control>, F: Fn(&P) + 'static>(this: *mut ffi::PkControl, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Control::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::version-micro\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_version_micro_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_5_2")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_5_2")))]
    #[doc(alias = "version-minor")]
    fn connect_version_minor_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_version_minor_trampoline<P: IsA<Control>, F: Fn(&P) + 'static>(this: *mut ffi::PkControl, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Control::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::version-minor\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_version_minor_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl<O: IsA<Control>> ControlExt for O {}
